{include file="template/header" title="软件设计 面向对象设计" /}

<div class="list list-number">
    <div class="title">基本原则</div>
    <div class="content open">
		<div class="list list-number">
			<div class="title">The Open Closed Principle - 开放-封闭原则</div>
			<div class="content closed">
				<p><span class="border border-dark rounded p-1">开放-封闭原则: 软件实体(类, 模块, 函数等等)可以扩展, 但是不能修改.</span></p>
				<p>说白了, 需求变化时, 可以添加新的代码, 但是不是更改已有的代码. </p>

				<p class="text-strong">开放-封闭原则带来的好处</p>
				<p>开放-封闭原则是OOP的核心所在! 遵循这个原则, 可以带来OOP所声称的巨大好处: 可维护, 可扩展, 可复用, 灵活性好.</p>	

				<p class="text-strong">怎样应对变化</p>
				<p>
					绝对的封闭是不可能的! 那么我们该怎么办呢?<br>
					1) 开始设计时, 先根据经验, 对有可能发生的变化(注意不要过度猜测), 构造抽象来隔离那些变化.<br>
					2) 设计完成后, 当变化发生时, 我们就创建抽象类, 隔离以后可能发生的同类变化!	
				</p>
				<p>变化发现的越晚, 要创建正确的抽象就越困难!</p>	
			</div>

			<div class="title">合成/聚合复用原则: 不要滥用继承</div>
			<div class="content closed">
				<p>
					就像我刚开始学会使用继承时, 感觉它既新颖又强大, 所以只要可以用, 就都用上继承. 这就好比是"有了新锤子, 所有的东西看上去都成了钉子." 但事实上, 很多情况用继承会带来麻烦. 因为:<br><br>
					1) 继承是编译时的: 对象的继承关系是在编译时就定义好了, 所以无法在运行时改变从父类继承的实现.<br>
					2) 子类的实现与它的父类有着非常紧密的依赖关系, 以至于父类实现中的任何变化必然导致子类发生变化.<br>
					3) 当你需要复用子类时, 如果继承下来的实现不适合解决新的问题, 则父类必须重写或被其他更适合的类替换.  
				</p>
				<p>这种依赖关系限制了灵活性并最终限制了复用性. 所以我们在使用继承时, 当且仅当是"is-a"的关系时才考虑使用! 如果是"has-a"的关系, 则考虑合成/聚合:</p>
				<p><span class="border border-dark rounded p-1">合成/聚合复用原则(CARP): 尽量使用合成/聚合, 尽量不要使用类继承!</span></p>
				<p>
					优先使用对象的合成/聚合将有助于你保持每个类被封装, 并被集中在单个任务上. 这样类和类继承层次会保持较小规模, 并且不太可能增长为不可控制的庞然大物.
				</p>

				<p class="text-strong">合成/聚合 & 继承优缺点比较</p>
				<table class="table table-bordered table-sm w-75">
					<tbody>
						<tr>
							<th>合成/聚合</th>
							<th>继承</th>
						</tr>
						<tr>
							<td>优点: 不破坏封装, 整体类与局部类之间耦合松散, 彼此相对独立</td>
							<td>缺点: 破坏封装, 子类与父类之间紧密耦合, 子类依赖于父类的实现, 子类缺乏独立性.</td>
						</tr>
						<tr>
							<td>优点: 具有较好的可扩展性</td>
							<td>缺点: 支持扩展, 但是往往以增加系统结构的复杂度为代价</td>
						</tr>
						<tr>
							<td>优点: 支持动态组合. 在运行时, 整体对象可以选择不同类型的局部对象</td>
							<td>缺点: 不支持动态继承, 在运行时, 子类无法选择不同的父类</td>
						</tr>
						<tr>
							<td>优点: 整体类可以对局部类进行包装, 封装局部类的接口, 提供新的接口</td>
							<td>缺点: 子类不能改变父类的接口</td>
						</tr>
						<tr>
							<td>缺点: 整体类不能自动获得和局部类同样的接口</td>
							<td>优点: 子类能自动继承父类的接口</td>
						</tr>
						<tr>
							<td>缺点: 创建整体类的对象时, 需要创建所有局部类的对象</td>
							<td>优点: 创建子类的对象时, 无须创建父类的对象</td>
						</tr>
					</tbody>
				</table>
			</div>

			<div class="title">The Dependency Inversion Principle - 依赖倒转原则: 针对接口或抽象类来编程</div>
			<div class="content closed">
				<p><span class="border border-dark rounded p-1">依赖倒转原则: ① 高层模块不应该依赖底层模块. 两个都应该依赖抽象. ② 抽象不应该依赖细节, 细节应该依赖抽象.</span></p>
				<p>说白了, 就是要针对接口或抽象类来编程, 不要针对实现编程.</p>
				<p>
					在面向过程的开发中, 为了使得常用代码可以复用, 一般都会把这些常用代码写成函数库的形式, 这样我们在做新项目时, 去调用这些底层的函数就可以了. <br>
					比如我们做的项目大多要访问数据库, 所以我们就把访问数据库的代码写成了函数, 每次做新项目时就去调用这些函数. 这也叫做高层模块依赖底层模块. <br>
					问题就出在这里, 我们要做新项目时, 发现业务逻辑的高层模块都是一样的, 但客户却希望使用不同的数据库, 这时就出现麻烦了. 我们希望再次利用这些高层模块, 但高层模块都是与底层的访问数据库绑定在一起的. 没办法复用这些高层模块, 这就非常糟糕了. 
				</p>
				<p>
					就好比是, PC里面如果CPU, 内存, 硬盘都需要依赖具体的主板, 主板一坏, 所有的部件就都没用了, 这显然不合理. 反过来, 如果内存坏了, 也不应该造成其他部件不能用才对. <br>
					而如果不管高层模块还是底层模块, 它们都依赖于抽象, 具体一点就是接口或抽象类, 只要接口是稳定的, 那么任何一个的更改都不用担心其他受到影响, 这就使得无论高层模块还是底层模块都可以很容易地被复用. 	
				</p>
				<p>
					依赖倒转其实可以说是OOP的标志, 用哪种语言来编写程序不重要, 如果编写时考虑的都是如何针对抽象编程, 而不是针对细节编程, 即程序中所有的依赖关系都是终止于抽象类或者接口, 那就是面向对象的设计, 反之就是过程化的设计.
				</p>
			</div>

			<div class="title">The Single Responsibility Principle - 单一职责原则: 职责不能太多</div>
			<div class="content closed">
				<p><span class="border border-dark rounded p-1">单一职责原则: 就一个类而言, 应该仅有一个引起它变化的原因.</span></p>
				<p>如果一个类承担的职责过多, 就等于把这些职责耦合在一起, 一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力. 这种耦合会导致脆弱的设计, 当变化发生时, 设计会遭受到意想不到的破坏.</p>	
				<p>就拿俄罗斯方块游戏来说, 可以表示为一个二维整型数组, 所谓的游戏逻辑, 下落, 旋转, 碰撞判断, 移动, 堆积这些都是在做数组具体项的值的变化. 而界面表示逻辑, 不过是根据数组的数值进行绘出和擦除, 或者根据键盘命令调用数组的相应方法进行改变. 因此, 至少应该考虑将此程序分为两个类, 一个是游戏逻辑的类, 一个是WinForm窗体的类. 当有一天要改变界面, 或者换界面时, 不过是窗体类的变化, 和游戏逻辑无关, 以此达到复用的目的.</p>
				<p>
					软件设计真正要做的许多内容, 就是发现职责并把那些职责相互分离. <br>
					其实要去判断是否应该分离出类来, 也不难, 那就是如果你能够想到多于一个的动机去改变一个类, 那么这个类就具有多于一个的职责, 就应该考虑类的职责分离. <br>
					做到了单一职责, 这样你的代码才是真正的易维护, 易扩展, 易复用, 灵活多样</p>
			</div>

			<div class="title">The Liskov Substitution Principle - 里氏转换原则: 子类可以替换父类</div>
			<div class="content closed">
				<p><span class="border border-dark rounded p-1">里氏转换原则(LSP): 子类型必须能够替换掉它们的父类型.</span></p>
				<p>说白了, 一个软件实体如果使用的是一个父类的话, 那么一定适用于其子类, 而且它觉察不出父类对象和子类对象的区别. 也就是说, 在软件里面, 把父类替换成它的子类, 程序的行为没有变化.</p>
				<p>正是因为有了这个原则, 使得继承复用成为了可能, 只有当子类可以替换掉父类, 软件单位功能不受到影响时, 父类才能真正被复用, 而子类也能够在父类的基础上增加新的行为.</p>
				<p>正是由于子类型的可替换性才使得使用父类型的模块在无需修改的情况下就可以扩展. 不然还谈什么扩展开放, 修改关闭.</p>
			</div>

			<div class="title">The Interface Segregation Principle 介面分離原則 </div>
			<div class="content closed">
				<p>不能强迫使用者去依赖那些他们不使用的介面. 换句话说, 使用多个专门的介面比使用单一的总介面要好.</p>
			</div>

			<div class="title">迪米特法则</div>
			<div class="content closed">
				<p><span class="border border-dark rounded p-1">迪米特法则( 也叫最少知识原则) , 如果两个类不必彼此直接通信, 那么这两个类就不应当发生直接的相互作用. 如果其中一个类需要调用另一个类的某一个方法的话, 可以通过第三者转发这个调用.</span></p>
				<p>迪米特法则首先强调的前提是在类的结构设计上, 每一个类都应当尽量降低成员的访问权限, 也就是说, 一个类包装好自己的private状态, 不需要让别的类知道的字段或行为就不要公开.</p>
				<p>迪米特法则其根本思想, 是强调了类之间的松耦合. 类之间的耦合越弱, 越有利于复用, 一个处在弱耦合的类被修改, 不会对有关系的类造成波及.</p>
			</div>
		</div>
    </div>

    <div class="title">常用设计模式</div>
    <div class="content closed">

    </div>
</div>

{include file="template/footer" /}