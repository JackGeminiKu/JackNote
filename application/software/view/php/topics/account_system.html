{include file="template/header" title="PHP 账号体系" /}

<div class="list list-number">
    <div class="title">加密口令</div>
    <div class="content closed">
		<p>MySQL提供了一个名为SHA()的函数, 它会对文本应用一个加密算法. 其结果是一个加密串, 长度固定为40个十六进制字符, 而不论原始口令的长度是多少.</p>
		<p>由于SHA()是一个MySQL函数而不是PHP函数, 所以调用这个函数时, 要作为在表中插入口令的查询的一部分. 例如, 以下代码向mismatch_user表插入一个新用户, 在这里应当使用SHA()加密口令.</p>
		<pre class="prettyprint linenums">
<code>
insert into mismatch_user(username, password, join_date) values('jnettles', SHA('tatlover'), now());
</code>
		</pre>

		<p>SHA()函数是一种单向加密, 无法还原. 这是为了确保加密数据的安全性, 即使有人攻击你的数据库, 并偷走所有口令, 他们也无法对其解密.</p>
		<p>要了解用户登录时是否正确地输入了口令, 你并不需要知道用户的原始口令. 这是因为, 只要提供同样的文本串, SHA()就会生产相同的40字符编码.</p>
		<pre class="prettyprint linenums">
<code>
select * from mismatch_user where password = SHA('tatlover')
</code>
		</pre>
    </div>

    <div class="title">使用HTTP认证</div>
    <div class="content closed">
		<p>
			使用HTTP认证保证页面安全时, 在允许访问受保护的页面之前, 会弹出一个窗口请求输入用户名和口令. 
			用户输入的用户名和口令被存储在超级全局变量中: $_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW'].
		</p>

		<p class="text-strong">header()函数</p>
		<pre class="prettyprint linenums">
<code>
header('Content-Type: text/html');
</code>
		</pre>
		<p>
			header()函数会立即从服务器向浏览器发送一个首部, 而且这个函数必须在向浏览器发送任何具体内容之前调用. 
			这是一个非常严格的要求, 如果在首部之前即使只是发送了一个字符或空格, 浏览器也会拒绝并报错. 所以, header()函数调用应当放在PHP脚本中的所有HTML代码之前!
		</p>

		<p class="text-strong">HTTP认证首部</p>
		<p>发起HTTP认证必须要有两个首部, 它们完成两件非常特定的工作:</p>
		<pre class="prettyprint linenums">
<code>
header('HTTP/1.1 401 Unauthorized');                      // 让浏览器知道用户没有得到查看页面的授权
header('WWW-Authenticate: Basic realm="Guitar Wars"');    // 要求浏览器提示用户输入用户名和口令来进行认证. "Basic realm"(基本域)是用于唯一标识这个特定认证的一个短语, 它会出现在认证窗口
</code>
		</pre>

		<p class="text-strong">范例(Authorize.php脚本)</p>
		<pre class="prettyprint linenums">
<code>
&lt;?php
    // User name and password for authentication
    $username = 'rock';
    $password = 'roll';

    if (!isset($_SERVER['PHP_AUTH_USER']) || !isset($_SERVER['PHP_AUTH_PW']) || ($_SERVER['PHP_AUTH_USER'] != $username) || ($_SERVER['PHP_AUTH_PW'] != $password)) {
        // The user name/password are incorrect so send the authentication headers
        header('HTTP/1.1 401 Unauthorized');
        header('WWW-Authenticate: Basic realm="Guitar Wars"');
        exit('&lt;h2>Guitar Wars&lt;/h2>Sorry, you must enter a valid user name and password to access this page.');
    }
?>
</code>
		</pre>
		<p>
			点击确定认证按钮: 相当于会重新请求这个网页, 所以会进行if判断, 检查用户的认证信息 ... 一旦成功输入了对应一个给定域的用户名和口令, 浏览器会记住这个用户名和口令, 而同一域中后续的认证首部就不会再显示认证窗口. 简单来说, 同一域只认证一次! <br>
			点击取消认证按钮: 会调用exit()函数! <br>
			备注: 调试的时候$_SERVER['PHP_AUTH_USER']没有值啊!!!
		</p>

		<p class="text-strong">注销认证</p>
		<p>对于一个给定页面或一组页面只会完成一次HTTP认证, 只是在浏览器关闭时才会重置.</p>
    </div>

    <div class="title">使用cookie</div>
    <div class="content closed">
		<p>cookie数据由用户的浏览器存储在他们的计算机上, 而且cookie能够跨多个页面(脚本)持久保存, 甚至可以跨多个浏览器会话持久存储.</p>

		<p class="text-strong">设置cookie</p>
		<pre class="prettyprint linenums">
<code>
setcookie('username', 'sidneyk');                   // 默认浏览器关闭时, cookie将被删除
setcookie('username', 'sidneyk', time() + 3600);    // 1小时后, cookie将被自动删除
</code>
		</pre>

		<p class="text-storng">访问cookie</p>
		<pre class="prettyprint linenums">
<code>
$_COOKIE['username']
</code>
		</pre>

		<p class="text-strong">删除cookie</p>
		<pre class="prettyprint linenums">
<code>
setcookie('username', 'sidneyk', time() - 3600);    // 要删除一个cookie, 只需要将到期时间设置为过去的一个时间!
</code>
		</pre>
    </div>

    <div class="title">使用section</div>
    <div class="content closed">
		<p>就像cookie一样, session也可以存储信息, 只不过信息是存储在服务器上的, 而不是客户端.</p>
		<p>不同于cookie, session无法对一个session变量将数据存储多久做太多的控制, session往往在用户关闭浏览器时结束.</p>

		<p class="text-strong">开始会话</p>
		<pre class="prettyprint linenums">
<code>
session_start();
</code>
		</pre>

		<p class="text-strong">使用会话变量</p>
		<pre class="prettyprint linenums">
<code>
$_SESSION['username'] = 'sidneyk';    // 一旦使用session_start()开始了一个会话, 就可以使用会话变量.
</code>
		</pre>
		<p>
			禁用cookie的情况下要让会话正常工作, 还需要利用另外一个机制, 在不同页面之间传递会话ID. 这个机制需要将会话ID追加到每个页面的URL后面: <br>
			1) 如果服务器上php.ini文件中的session_use_trans_id被设置为1(true), 这就会自动发生. <br> 
			2) 如果你无法修改Web服务器上的这个文件, 必须手动向会话页面的URL追加会话ID: &lt;a href="viewprofile.php?&lt;?php echo SID; ?>">view your profile&lt;/a> <br>
		</p>

		<p class="text-strong">销毁会话</p>
		<pre class="prettyprint linenums">
<code>
// 浏览器关闭, 或者调用了session_destory()函数时, 会话就会结束.
session_destory();   
// session_destory()函数实际上并不会销毁会话变量, 销毁一个会话的所有会话变量, 有一种快速有效的方法: 即把$_SESSION设置为一个空数组!
$_SESSION = array();
// 如果浏览器支持cookie, 会话可能会设置一个cookie临时存储会话ID. 所以要通过PHP代码完全关闭一个会话, 还必须删除可能在浏览器上自动创建来存储会话ID的所有cookie.
if (isset($_COOKIE[session_name()])) setcookie(session_name(), '', time() - 3600);
</code>
		</pre>
    </div>
</div>

{include file="template/footer" /}