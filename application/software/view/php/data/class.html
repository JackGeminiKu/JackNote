{include file="template/header" title="PHP 类" /}

<div class="list list-number">
    <div class="title">各种类</div>
    <div class="content open">
		<div class="list list-number">

			<!--自定义类-->
			<div class="title">自定义类</div>
			<div class="content closed">
				<pre class="prettyprint linenums lang-php">
<code>
[final] class Dog extends Animal implements iSay    // final关键字禁止子类继承该类
{
    // 构造函数
    function _construct($param) {
    }

    // 常量
    const pi = 3.14159;    // 类常量: 在定义和使用常量的时候不需要使用$符号. 常量的值必须是一个定值, 不能是变量, 类属性, 数学运算的结果或函数调用.
	
    // 属性
    private | protected | public $attribute;    // 属性. 可重载父类属性

    private | protected | public function __get($name) {    // 读属性
        return $this->$name;
    }
    private | protected | public function __set($name, $value) {    // 写属性
        $this->$name = $value;
    }

    // 函数
    [final] private | protected | public function operation($param) {    
        // 调用类中定义的方法: $this->funcName()
        // 可重载父类操作, 可调用父类的opertion操作形式如下: parent::opeartion(); 
    }   

    // 静态成员
    static function squared($input) {    // 静态方法
        // 不能使用this关键字
    }
	
    // 析构函数
    function _destruct() { 
        // 无参数
    }
}
</code>
				</pre>
			</div>

			<!--静态成员 & 静态类-->
			<div class="title">静态成员 & 静态类</div>
			<div class="content closed">
				<pre class="prettyprint linenums">
<code>
class Human{
　　static public $name = "小妹";
　　public $height = 180;

　　static public function tell(){
　　　　echo self::$name;　　    //静态方法调用静态属性，使用self关键词!
　　　　//echo $this->height;　　//错! 静态方法不能调用非静态属性!
　　}

　　public function say(){
　　　　echo self::$name . "我说话了"; 　　//普通方法可以调用静态属性，同样使用self关键词
　　　　echo $this->height;
　　}
}
</code>
				</pre>
				<a href="https://www.cnblogs.com/moxiaoan/p/6228948.html" target="_blank">网上资料</a>
			</div>

			<!--抽象类-->
			<div class="title">抽象类</div>
			<div class="content closed">
				<pre class="prettyprint linenums lang-php"><code>abstract class A {
    abstract function Operation($param);    // 抽象方法只能存在于抽象类中.
}</code></pre>
			</div>

		</div> 
    </div>

    <div class="title">使用类&对象</div>
    <div class="content open">
		<div class="list list-number">
			<div class="title">实例化</div>
			<div class="content closed">
				<pre class="prettyprint linenums lang-php"><code>$a = new classname('First');
$a = $b;    // 引用
$a = clone $b;    // 拷贝</code></pre>
			</div>

			<div class="title">使用类&对象</div>
			<div class="content closed">
				<pre class="prettyprint linenums lang-php">
<code>
// 调用对象成员
$a->operation($param);    // 使用对象的方法

// 调用类成员
classname::pi;    // 使用常量
classname::squared(8);    // 调用类的静态方法
</code>
				</pre>
			</div>
		</div>
    </div>

	<!--高级功能-->
	<div class="title">高级功能</div>
	<div class="content open">
		<div class="list list-number">

			<!--__autoLoad() & spl_autoload_register()-->
			<div class="title">自动加载: __autoLoad() & spl_autoload_register()</div>
			<div class="content closed">
				<p><strong>__autoLoad()</strong>是一个自动加载函数，在PHP5中，当我们实例化一个未定义的类时，就会自动调用这个函数。看下面例子：</p>
				<pre class="prettyprint linenums lang-php">
<code>
// printit.class.php
class PRINTIT {
    function doPrint() {
        echo 'hello world';
    }
}
</code>
				</pre>
				<pre class="prettyprint linenums">
<code>
// index.php
function __autoload( $class ) {
    $file = $class . '.class.php';
    if ( is_file($file) ) {
        require_once($file);
    }
}

$obj = new PRINTIT();    // 实例化printit时, 由于没有包含printit.class.php, 将自动调用__autoload函数, 参数$class的值即为类名printit, 此时printit.class.php就被引进来了.
$obj->doPrint();
</code>
				</pre>
				<p>
					运行index.php后正常输出hello world。
				</p>
				<p>
					在面向对象中这种方法经常使用，可以避免书写过多的引用文件，同时也使整个系统更加灵活。
				</p>
				<p><strong>spl_autoload_register()</strong>是一个自动加载函数，在PHP5中，当我们实例化一个未定义的类时，就会自动调用这个函数指定的函数。看下面例子：</p>
				<pre class="prettyprint linenums lang-php">
<code>
function loadprint( $class ) {
    $file = $class . '.class.php';
    if (is_file($file)) {
        require_once($file);
    }
}

spl_autoload_register( 'loadprint' );    // 告诉PHP碰到没有定义的类就自动调用loadprint()

$obj = new PRINTIT();
$obj->doPrint();
</code>
				</pre>
				<pre class="prettyprint linenums">
<code>
// 也可以调用静态方法
class test {
    public static function loadprint( $class ) {
        $file = $class . '.class.php';
        if (is_file($file)) {
            require_once($file);
        }
    }
}

spl_autoload_register( array('test','loadprint') );    //另一种写法：spl_autoload_register( "test::loadprint" );

$obj = new PRINTIT();
$obj->doPrint();
</code>
				</pre>
			</div>

			<!--遍历类的属性-->
			<div class="title">遍历类的属性</div>
			<div class="content closed">
				<pre class="prettyprint linenums lang-php">
<code>
$x = new myClass;
foreach($x as $attribute) {
    echo $attribute;
}
</code>
				</pre>
			</div>

			<!--使用迭代器&迭代-->
			<div class="title">使用迭代器和迭代</div>
			<div class="content closed">
				<p>Iterator接口和IteratorAggregate接口 P138</p>
			</div>

			<!--反射-->
			<div class="title">反射</div>
			<div class="content closed">
				<pre class="prettyprint linenums lang-php">
<code>
$class = new ReflectionClass('page');
echo $class;
</code>
				</pre>
			</div>

			<!--this, selft & parent-->	
			<div class="title">this, selft & parent</div>
			<div class="content closed">
				<p>
					this: 当前对象,<br>
					self: 当前类,<br>
					parent: 父类
				</p>
			</div>	
		</div>
	</div>

	<!--对象之间的关系-->
	<div class="title">对象之间的关系</div>
	<div class="content closed">

	</div>
</div>

{include file="template/footer" /}