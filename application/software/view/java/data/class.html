{include file="template/header" title="Java 类" /}
<ol dynamicoutline="" initcollapsed="">
	<li>定义<ul initcollapsed="" dynamicoutline="">
			<li>
				<table border="1" width="80%" bordercolor="#CCE8CF" id="table1">
					<tbody><tr>
							<td>
								<p style="margin-top: 0; margin-bottom: 0">public class 
									Dog&nbsp; extends Animal&nbsp; // <font face="宋体">① </font>一个源文件中最多只能有一个public类. 其他类的个数不限. 如果源文件包含了一个public类, 
									它必须按类名命名! <font face="宋体">② </font>类名首字母要大写.</p><p><b>继承</b></p>
								<p>通过extends, 子类可以继承父类中的成员, 但是, 父类可以通过存取权限决定子类能够访问父类的哪些成员, 
									我们有4种存取权限</p>
								<table border="1" width="60%" bordercolor="#000000" id="table5" style="cursor: default; font-family: Microsoft YaHei; font-size: 10pt; padding: 2">
									<tbody><tr style="font-family: Microsoft YaHei; font-size: 10pt">
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2" bgcolor="#C0C0C0">
												修饰符</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2" bgcolor="#C0C0C0">
												类内部</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2" bgcolor="#C0C0C0">
												同一个包</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2" bgcolor="#C0C0C0">
												子类</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2" bgcolor="#C0C0C0">
												任何地方</td>
										</tr>
										<tr style="font-family: Microsoft YaHei; font-size: 10pt">
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												private</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
						　</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
						　</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
						　</td>
										</tr>
										<tr style="font-family: Microsoft YaHei; font-size: 10pt">
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												default</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
						　</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
						　</td>
										</tr>
										<tr style="font-family: Microsoft YaHei; font-size: 10pt">
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												protected</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
						　</td>
										</tr>
										<tr style="font-family: Microsoft YaHei; font-size: 10pt">
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												public</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
											<td style="line-height: 150%; font-family: Microsoft YaHei; font-size: 10pt; margin-top: 16px; margin-bottom: 16px; padding: 2">
												Yes</td>
										</tr>
									</tbody></table>
								<p style="margin-top: 16px; margin-bottom: 16px"><b>Object类型</b></p><p style="margin-top: 16px; margin-bottom: 16px">
									Object是所有类型的基类, 如果创建类的时候没有指定父类, 则默认它的父类为Object!</p><p style="margin-top: 0; margin-bottom: 0">{</p></td>
						</tr>
						<tr>
							<td>
								<ol initcollapsed="" dynamicoutline="">
									<li>成员变量<ul>
											<li>private String name;</li>
										</ul></li>
									<li>构造方法 - 不能继承<ul>
											<li>public Duck( ) {<br>&nbsp;&nbsp;&nbsp; // 和类同名, 
												没有返回值<br>}</li>
											<li><b>子类构造方法 &amp; 父类构造方法</b></li>
											<li>构造方法在执行的时候, 会先执行父类的构造方法, 这会连锁反应到Object这个类为止. </li>
											<li><font face="华文行楷">注意: 这里有个地方要注意, 就算是抽象的类也有构造方法. 虽然你不能对抽象的类执行new操作, 
												但抽象的类还是父类, 因此它的构造方法会在具体子类创建出实例时执行.</font></li>
											<li>public Duck( ){<br>&nbsp;&nbsp;&nbsp; super( ... ) ;&nbsp; 
												// 默认调用父类的默认构造方法, 但是可以指定调用父类的哪个构造方法: 显式使用super(...), 
												只能放在第一行!<br>&nbsp;&nbsp;&nbsp; ...<br>}</li>
											<li><b>调用本类构造方法: this( )</b></li>
											<li>public Duck( ){<br>&nbsp;&nbsp;&nbsp; this( ... );&nbsp; 
												// 可用用来调用类中的其他构造方法, 但是只能放在第一行!<br>
												&nbsp;&nbsp;&nbsp; ...<br>}</li>
											<li><b>默认构造方法(没有参数)</b></li>
											<li>默认构造方法是指没有参数的构造方法. 如果没有定义任何构造方法, 编译器会自动添加默认构造方法.</li>
										</ul></li>
									<li>Setter &amp; Getter<ul>
											<li>封装原则: 将你的成员变量标记为私有的, 
												并提供公有的getter与setter来控制存取动作<p>String getName( ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// getter<br>&nbsp;&nbsp;&nbsp; 
													return name;<br>}</p>
												<p>void setName( String aName ) {&nbsp;&nbsp;&nbsp; 
													// setter<br>&nbsp;&nbsp;&nbsp; name = aName;<br>}</p>
											</li>
										</ul></li>
									<li>
										<p style="margin-bottom: 16px">方法</p>
										<ol>
											<li>定义<ul>
													<li>
														<table id="table26" bordercolor="#CCE8CF" width="95%" border="1">
															<tbody><tr>
																	<td valign="top" colspan="2">[ private | 
																		public ] [ static ] return_type methodName ( 
																		[ parameters ] )<br>{<br>&nbsp;&nbsp;&nbsp; 
																		// Method body<br>}</td>
																</tr>
																<tr>
																	<td valign="top" width="98"><b>1) 函数名</b></td>
																	<td valign="top" width="1119">方法名关系到程序的可读性, 
																		一般采用小骆驼拼写法 + 动名词, 起的要有意义.<br>
																		<font face="標楷體">(第一个单词的首字母小写，后面每个单词的首字母大写，叫做"小骆驼拼写法"(lowerCamelCase))</font></td>
																</tr>
																<tr>
																	<td valign="top" width="98"><b>2) 参数</b></td>
																	<td valign="top" width="1119">
																		<table id="table27" bordercolor="#cce8cf" width="110%" border="1">
																			<tbody><tr>
																					<td width="100%">
																						<p style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px">Java方法都是通过值传递的, 也就是说通过拷贝传递. 对于引用类型, 
																							由于传递的是"地址", 所以实参和形参指向同一个对象!</p>
																						<p style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px">
																							<font color="#C0C0C0">　</font></p></td>
																				</tr>
																			</tbody></table></td>
																</tr>
																<tr>
																	<td valign="top" width="98"><b>3) 返回值</b>
																	</td>
																	<td valign="top" width="1119">void - return;<br>value - return value;</td>
																</tr>
															</tbody></table></li>
												</ul></li>
											<li>异常处理<ol nodynamicoutline="">
													<li>自定义异常<ul>
															<li>
																<table border="1" width="80%" bordercolor="#C0C0C0" bgcolor="#C0C0C0" id="table35">
																	<tbody><tr>
																			<td>class MyException extends Exception {<br>&nbsp;&nbsp;&nbsp; ...<br>}</td>
																		</tr>
																	</tbody></table></li>
														</ul></li>
													<li>throw异常<ul>
															<li>
																<table border="1" width="80%" bordercolor="#C0C0C0" bgcolor="#C0C0C0" id="table36">
																	<tbody><tr>
																			<td>public void takeRisk( ) throws BadException&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
																				// 表示这个方法会抛出BadException异常, 或者BadException子类型异常<br>&nbsp;&nbsp;&nbsp; 
																				if (abandonAllHope) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
																				throw new BadException( );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
																				// 抛出异常, 后面的代码不会执行了!<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>public void takeRisk( ) throws ExceptionA, ExceptionB&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
																				// 抛出多个异常<br>&nbsp;&nbsp;&nbsp; ...<br>}</td>
																		</tr>
																	</tbody></table></li>
														</ul></li>
													<li>异常捕获&amp;处理<ul>
															<li><b>1) catch异常</b><table border="1" width="80%" bordercolor="#C0C0C0" bgcolor="#C0C0C0" id="table37">
																	<tbody><tr>
																			<td>Java虚拟机会从头开始, 往下找到第一个符合范围的异常处理块.<p style="margin-bottom: 0">try {<br>&nbsp;&nbsp;&nbsp; Sequencer sequencer = 
																					MidiSystem.getSequencer();<br>&nbsp;&nbsp;&nbsp; 
																					System.out.println("We got a sequencer"); <br>} catch ( 
																					MidiUnavailableException e ) {<br>&nbsp;&nbsp;&nbsp; 
																					e.printStackTrace();<br>} catch( Exception ex) {<br>&nbsp;&nbsp;&nbsp; ...<br>} finally {<br>&nbsp;&nbsp;&nbsp; // 不管是否异常, 都会执行, 
																					哪怕try或者catch中有return语句!!!<br>&nbsp;&nbsp;&nbsp; // 可以省略.<br>}</p></td>
																		</tr>
																	</tbody></table></li>
															<li><b>2) duck异常</b>: 不处理, 抛给调用方!<table border="1" width="80%" bordercolor="#C0C0C0" bgcolor="#C0C0C0" id="table38">
																	<tbody><tr>
																			<td>public void foo( ) throws BadException&nbsp;{&nbsp; // 不处理异常, 
																				所以这个方法可能会抛出异常!<br>&nbsp;&nbsp;&nbsp; takeRisk( );<br>}</td>
																		</tr>
																	</tbody></table></li>
														</ul></li>
													<li>重写方法时<ul>
															<li>重写方法时, 需要抛出和原方法所抛出异常类型一致的异常, 或者干脆不抛出异常!</li>
														</ul></li>
													<li><b>异常家族</b><ul>
															<li>
																<table border="1" width="80%" bordercolor="#CCE8CF" id="table39">
																	<tbody><tr>
																			<td width="409">
																				<img border="0" src="../Method.files/Java异常分类.png" width="337" height="158"></td>
																			<td valign="top">1) Throwable是所有Error和Exception的父类.<p>2) 
																					Error是不能Catch的. Exception是可以Catch的.</p>
																				<p>3) RuntimeException是可以catch的, 而其他异常是必须catch的, 否则不能编译!</p>
																				<p>　</p></td>
																		</tr>
																	</tbody></table></li>
														</ul></li>
												</ol></li>
											<li>递归<ul>
													<li><span style="font-weight: 400">方法自己调用自己...</span></li>
													<li>
														<table border="1" width="80%" bordercolor="#C0C0C0" bgcolor="#C0C0C0" id="table40">
															<tbody><tr>
																	<td>// 求Fibonacci数列的值: 1,1,2,3,5,8, ...<br>public static int 
																		fibonacci(int n) {<br>&nbsp;&nbsp;&nbsp; if (n == 1 || n == 2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
																		return 1;<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
																		return fibonacci(n -1) + fibonacci(n - 2);<br>&nbsp;&nbsp;&nbsp; 
																		}<br>}</td>
																</tr>
															</tbody></table></li>
												</ul></li>
											<li>入口函数<ul>
													<li>
														<table border="1" width="90%" bordercolor="#C0C0C0" bgcolor="#C0C0C0" id="table41">
															<tbody><tr>
																	<td>
																		<p class="MsoNormal" style="margin-top: 0; margin-bottom: 0">
																			<span lang="EN-US">public static void main(String[] args)</span></p>
																		<p class="MsoNormal" style="margin-top: 0; margin-bottom: 0">
																			<span lang="EN-US">{</span></p>
																		<p class="MsoNormal" style="margin-top: 0; margin-bottom: 0">
																			<span lang="EN-US">&nbsp;&nbsp;&nbsp; // 
																			</span><span style="font-family: 新細明體">所有Java应用程式, 都从这里开始执行!</span></p>
																		<p class="MsoNormal" style="margin-top: 0; margin-bottom: 0">
																			<span lang="EN-US">}</span></p></td>
																</tr>
															</tbody></table></li>
												</ul></li>
											<li>
												<p style="margin-bottom: 16px"><b>重写</b></p>
												<ul>
													<li>
														<p style="margin-bottom: 16px">public String toString( ) 
															{&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // 
															子类对于继承的方法不"满意", 可以重写方法的实现!<br>}</p></li>
												</ul></li>
											<li>
												<p style="margin-bottom: 16px"><b>重载</b></p>
												<ul>
													<li>
														<p style="margin-bottom: 16px">Java支持方法重载. 
															所谓重载就是指方法名相同, 但是参数类型或者个数不同.</p></li>
												</ul></li>
											<li>
												<p style="margin-bottom: 16px"><b>多态</b></p>
												<ul>
													<li>Animal animal = new Dog( );&nbsp; // 运用多态时, 父类变量可以指向子类实例.</li>
													<li>如上所示, 由于animal声明为Animal类型, 所以只能调用Animal中定义的方法.<br>如上所示, 调用animal.makeNoise( )方法时, 由于Dog类型重新了makeNoise( 
														)方法, 所以调用的是重写后的方法, 这一点要注意!</li>
													<li>使用多态, 可以提升软件的课扩展性!</li>
												</ul></li>
										</ol>
									</li>
									<li>
										<p style="margin-bottom: 16px">事件</p>
										<ul>
											<li>
												<table border="1" width="90%" bordercolor="#C0C0C0" bgcolor="#C0C0C0" id="table2">
													<tbody><tr>
															<td>import javax.swing.*;<br>import java.awt.event.*;<br>
																<br>public class SimpleGuiB implements ActionListener {&nbsp;&nbsp;&nbsp;
																<font color="#006600">// 如果想要接收ActionEvent事件的话, 就必须实现ActionListener这个接口</font><br>&nbsp;&nbsp;&nbsp; JButton button;<br>
																<br>&nbsp;&nbsp;&nbsp; public static void main( String[] args )&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SimpleGuiB gui = new SimpleGuiB();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gui.go();<br>&nbsp;&nbsp;&nbsp; }<br>
																<br>&nbsp;&nbsp;&nbsp; public void go() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JFrame frame = new JFrame();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; button = new JButton("click me");<br>
																<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; button.addActionListener(this);&nbsp;&nbsp;&nbsp;
																<font color="#006600">// 向按钮注册</font><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame.getContentPane().add(button);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame.setSize(300,300);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame.setVisible(true);<br>&nbsp;&nbsp;&nbsp; }<br>
																<br>&nbsp;&nbsp;&nbsp; public void actionPerformed(ActionEvent event) {&nbsp;&nbsp;&nbsp;
																<font color="#006600">// 实现interface上的方法, 这是真正处理事件的方法</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; button.setText("I've been clicked!");<br>&nbsp;&nbsp;&nbsp; }<br>}</td>
														</tr>
													</tbody></table></li>
										</ul></li>
									<li>this关键字<ul>
											<li>代表当前对象.</li>
										</ul>
									</li>
									<li>super关键字<ul>
											<li>代表当前对象中的父对象!</li>
										</ul>
									</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td>}</td>
						</tr>
					</tbody></table>
			</li>
		</ul>
	</li>
	<li>静态类 &amp; 静态成员<ol nodynamicoutline="">
			<li>静态变量<ul>
					<li>静态变量是被同类的所有实例共享的变量!</li>
					<li>
						<table border="1" width="60%" bordercolor="#CCE8CF">
							<tbody><tr>
									<td width="520"><b>定义</b></td>
									<td width="520"><b>使用</b></td>
								</tr>
								<tr>
									<td width="520" bgcolor="#C0C0C0">public class Duck<br>{<br>&nbsp;&nbsp;&nbsp; public static int duckCount = 0;<br>
										<br>&nbsp;&nbsp;&nbsp; public Duck( ) <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; duckCount ++;<br>&nbsp;&nbsp;&nbsp; }<br>}</td>
									<td width="520" bgcolor="#C0C0C0" valign="top">Duck.duckCount;</td>
								</tr>
							</tbody></table></li>
					<li><b>初始化</b></li>
					<li>静态变量是在类被加载时初始化的. 通常, 
						Java虚拟机会加载某个类是因为第一次有人尝试要创建该类的新实例, 或是使用该类的静态方法或变量. 
						所以静态变量会在任何对象创建之前或者任何静态方法被执行之前就被初始化!</li>
				</ul></li>
			<li>静态方法<ul>
					<li>静态方法是属于类的方法, 使用静态方法时, 不会在堆上创建实例!!!</li>
					<li>静态成员只能访问静态成员, 而非静态成员可以访问非静态成员和静态成员!</li>
					<li>
						<table border="1" bordercolor="#CCE8CF" width="892">
							<tbody><tr>
									<td width="445"><b>定义</b></td>
									<td width="445"><b>使用</b></td>
								</tr>
								<tr>
									<td width="445" bgcolor="#C0C0C0">public class Math<br>{<br>&nbsp;&nbsp;&nbsp; public static int min( int a, int b )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 返回a与b中较小的值<br>&nbsp;&nbsp;&nbsp; }<br>}</td>
									<td valign="top" bgcolor="#C0C0C0" width="445">Math.min(1,2);</td>
								</tr>
							</tbody></table></li>
				</ul></li>
		</ol></li>
	<li>抽象类 &amp; 抽象成员<ul>
			<li>抽象类不能实例化, 但是你可以使用抽象类来声明为引用类型给多态使用.<table border="1" width="80%" bordercolor="#C0C0C0" bgcolor="#C0C0C0" id="table6">
					<tbody><tr>
							<td><p style="margin-top: 0; margin-bottom: 0">abstract 
									class Canine extends Animal<br>{<br>&nbsp;&nbsp;&nbsp; // 抽象方法<br>&nbsp;&nbsp;&nbsp; public 
									abstract void roam( );&nbsp; // 子类要么实现这个方法, 要么具体声明为抽象方法!</p>
								<p style="margin-top: 0; margin-bottom: 0">&nbsp;&nbsp;&nbsp; // 非抽象方法<br>&nbsp;&nbsp;&nbsp; 
									public void breath( ) {<br>
									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
									&nbsp;&nbsp;&nbsp; }<br>}</p>
							</td>
						</tr>
					</tbody></table>
				<p><b>抽象类的子类</b></p>
				<p>抽象类的子类可以实现父类的抽象方法, 或者不实现父类的抽象方法, 而是让它的子类来实现.</p></li>
		</ul>
	</li>
	<li>final类 &amp; final成员<ol>
			<li>常数<ul>
					<li>
						<table border="1" width="66%" bordercolor="#CCE8CF">
							<tbody><tr>
									<td width="482">1) 声明&amp;赋值</td>
									<td>2) 先声明, 后赋值</td>
								</tr>
								<tr>
									<td width="482" valign="top" bgcolor="#C0C0C0">public static 
										final double PI = 3.1415926</td>
									<td bgcolor="#C0C0C0">public static final double PI;<br>
										static {<br>&nbsp;&nbsp;&nbsp; PI = 3.1415926;<br>}</td>
								</tr>
							</tbody></table>
						<p>静态初始化程序是一段在加载类时会执行的程序代码, 它会在其他程序可以使用该类之前就执行, 所以很适合放静态final变量的起始程序.</p></li>
				</ul></li>
			<li>final变量 ( 非静态 )<ul>
					<li>final变量不能重新赋值! 方法参数也可以用final修饰!</li>
					<li>
						<table border="1" width="35%" bordercolor="#C0C0C0" bgcolor="#C0C0C0">
							<tbody><tr>
									<td>final int size = 3;</td>
								</tr>
							</tbody></table></li>
				</ul></li>
			<li>final方法<ul>
					<li>final方法不能被子类重写!</li>
					<li>
						<table border="1" width="519" bordercolor="#C0C0C0" bgcolor="#C0C0C0">
							<tbody><tr>
									<td width="513">final void calcWhuffie( )<br>{ }</td>
								</tr>
							</tbody></table></li>
				</ul></li>
			<li>final类<ul>
					<li>final类不能被子类继承!</li>
					<li>
						<table border="1" width="35%" bordercolor="#C0C0C0" bgcolor="#C0C0C0">
							<tbody><tr>
									<td>final class MyMostPerfectClass<br>{ }</td>
								</tr>
							</tbody></table></li>
				</ul></li>
		</ol></li>
	<li>泛型类 &amp; 泛型成员<ol nodynamicoutline="">
			<li>泛型类<ul>
					<li>
						<table border="1" width="80%" bordercolor="#C0C0C0" id="table3" bgcolor="#C0C0C0">
							<tbody><tr>
									<td>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; ... {<br>&nbsp;&nbsp;&nbsp; public boolean add(E o)<br>}</td>
								</tr>
							</tbody></table></li>
				</ul></li>
			<li>泛型方法<ul>
					<li>
						<table border="1" width="80%" bordercolor="#C0C0C0" id="table4" bgcolor="#C0C0C0">
							<tbody><tr>
									<td>public &lt;T extends Animal&gt; void takeThing&lt;ArrayList&lt;T&gt; list)</td>
								</tr>
							</tbody></table></li>
				</ul></li>
		</ol></li>
	<li>内部类 ( 寄生类 )<ul>
			<li>任何时候你需要一个独立却又好像另一个类成员之一的类时, 内部类可能是唯一的解.</li>
			<li>
				<table border="1" width="90%" bordercolor="#C0C0C0" bgcolor="#C0C0C0">
					<tbody><tr>
							<td>class MyOuterClass <br>{<br>&nbsp;&nbsp;&nbsp; class MyInnerClass<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
								<font color="#339933">// 
								内部类可以使用外部类所有的方法与变量, 包括private方法与变量!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 内部类实例和外部类实例之间存在"超友谊"的关系, 
								即内部类实例只能存取它所属的那一个外部类实例!<br></font>&nbsp;&nbsp;&nbsp; }<br>}</td>
						</tr>
					</tbody></table></li>
		</ul></li>
</ol>
{include file="template/footer" /}