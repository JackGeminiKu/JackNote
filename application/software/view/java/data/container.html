{include file="template/header" title="Java 容器类" /}
<div class="position-relative" style="top:0px;right:0px;">
	<img src="__STATIC__/image/java/Container.jpg" />
</div>
<p>
	HashSet: 防止重复的集合, 可以快速地找寻相符的元素. <br>
	TreeSet: 以有序状态保持并防止重复 <br>
	HashMap: key/value <br>
	LInkedHashMap: 类似HashMap, 但可记住元素插入的顺序, 也可以设定成依照元素上次存取的先后来排序. <br>
	LinkedList: 针对经常插入或删除中间元素所设计的高效率集合.
</p>

<div class="list list-number">
    <div class="title">List & 数组: 索引集合</div>
    <div class="content closed">
		<div class="list list-number">
			<div class="title">数组: 高效, 但元素数量固定</div>
			<div class="content closed">
				<div class="list list-number">
					<div class="title">声明</div>
					<div class="content open">
						<pre class="prettyprint linenums">
<code>
int[ ] nums;    // 声明
nums = new int[7];  // 构造
int[ ] nums = { 1, 3, 5 };  // 定义时就初始化
</code>
						</pre>
					</div>

					<div class="title">常用操作</div>
					<div class="content open">
						<div class="list list-none">
							<div class="title">读写元素</div>
							<div class="content open">
								<p>nums[0] = 0;</p>
							</div>

							<div class="title">获取数组长度</div>
							<div class="content open">
								<p>array.length;</p>
							</div>

							<div class="title">拷贝数组</div>
							<div class="content open">
								<p>System.arraycopy();</p>	
							</div>
						</div>
					</div>

					<div class="title">二维数组</div>
					<div class="content open">
						<p>二维数组本质上是一维数组, 只是它的元素类型是数组!</p>
						<pre class="prettyprint linenums">
<code>
int a[][] = { {1, 2}, {3, 4, 5, 6}, {7, 8, 9} };

int a[][] = new int[3][];  // "锯齿"数组
a[0] = new int[2];
a[1] = new int[4];
a[2] = new int[3];
</code>
						</pre>
					</div>
				</div>
			</div>

			<div class="title">ArrayList&lt;E>: 可动态添加/删除元素</div>
			<div class="content closed">
				<p>ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。</p>
			</div>

			<div class="title">Vector&lt;E>: 动态数组</div>
			<div class="content closed">
				<p>同ArrayList&lt;E>差不多, 但是Vector&lt;E>是线程安全的, 但是性能稍差.</p>
			</div>

			<div class="title">LinkedList&lt;E>: 双向链表</div>
			<div class="content closed">
				<p>LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率低。</p>
			</div>
		</div>
	</div>

	<div class="title">Set: 不允许重复的集合</div>
	<div class="content closed">
		<div class="list list-number">
			<div class="title">HashSet: 不重复</div>
			<div class="content open">
				<p>
					当把新的对象加入到HashSet时, HashSet会将新对象的hashCode值与已有对象的hashCode作比较: <br>
					1) 如果没有相符的hashCode, HashSet就把新对象加入进去; <br>
					2) 否则, 它就会调用其中一个的equals()来检查hashCode相等的对象是否真的相同: <br>
					2.1) 如果相同, HashSet就会知道要加入的项目已经重复了, 所以加入的操作就不会发生. <br>
					2.2) 否则, 就会把新对象加入进去. <br>
					先用hashCode缩小范围, 再用equals()确定是否相等!
				</p>
			</div>

			<div class="title">有序不重复</div>
			<div class="content open">
				<p>TreeSet在防止重复上面与HashSet是一样的. 但它还会一直保持集合处于有序状态. 如果使用TreeSet默认的构造函数, 它工作起来就会像sort()一样使用对象的compareTo()方法来排序. 但也可以选择传入Comparator给TreeSet的构造函数.</p>
			</div>
		</div>
	</div>

	<div class="title">Map: key-value集合</div>
	<div class="content closed">
		<div class="list list-number">
			<div class="title">HashMap</div>
			<div class="content open">

			</div>
		</div>
	</div>

	<div class="title">集合排序</div>
	<div class="content closed">
		<pre class="prettyprint linenums">
<code>
public static &lt;T extends Comparable&lt;? super T>> void sort(List&lt;T> list)    // 调用T的Compare方法比较, 所以T必须实现Comparable接口.
public static &lt;T> void sort(List&lt;T> list, Comparator&lt;? super T> c) // 根据指定比较器产生的顺序对指定列表进行排序, 必须实现Comparator&lt;T>接口
</code>
		</pre>
	</div>

	<div class="title">数组或者ArrayList作为函数形参</div>
	<div class="content closed">
		<pre class="prettyprint linenums">
<code>
public void takeAnimal(Animal[] animals)
参数是数组, Dog数组或者Cat数组都是合法的.

public void takeThing(ArrayList&lt;Animal> list)
参数是ArrayList, 只有ArrayList&lt;Animal>是合法的.

public &lt;T extends Animal> void takeThing(ArrayList&lt;T> list)
泛型方法, T是Animal系列类型.

public void takeThing(ArrayList<? extends Animal> animal)
万用字符: 同上面的泛型方法, 但是编译器不会让你加入任何东西到集合中!

此处的extends同时代表继承和实现
</code>
</pre>
	</div>
</div>
{include file="template/footer" /}