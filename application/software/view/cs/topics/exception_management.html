{include file="template/header" title="C# 异常管理" /}

<p>
	1. 抛出异常<br>
	什么时候可以抛出异常?<br>
	自定义异常<br>

	2. 捕捉异常<br>
	什么情况下要捕捉异常?<br>
	如何传播异常?<br>
	未捕捉的异常怎么处理?<br>
	无法处理的异常怎么办?<br>
	如何提示异常信息?<br>
	如何处理异常<br>

	3. 其他<br>
	异常 vs 错误代码<br>
	Application Instrmentation<br>
	Specific Technology Considerations<br>
</p>

<div class="list list-number">
	<div class="title">抛出异常</div>
	<div class="content closed">
		<div class="list list-number">
			<div class="title">什么时候可以抛出异常?</div>
			<div class="content closed">
				<p>
					You should only throw exceptions when a condition outside of your code's assumptions occurs. In other words,
					you should not use exceptions as a means to provide your intended functionality. 
				</p>
				<p>
					For example, a user might
					enter an invalid user name or password while logging on to an application. While this is not a successful logon, it
					should be a valid and expected result, and therefore should not throw an exception. <br>
					However, an exception should be generated if an unexpected condition occurs, such as an unavailable user database. 
				</p>
				<p>
					Throwing
					exceptions is more expensive than simply returning a result to a caller. Therefore they should not be used to
					control the normal flow of execution through your code. In addition, excessive use of exceptions can create
					unreadable and unmanageable code.	
				</p>
			</div>

			<div class="title">自定义异常</div>
			<div class="content closed">
				<div class="list list-number">
					<div class="title">自定义类层次</div>
					<div class="content closed">
						<img src="__ROOT__/static/image/cs/application_exception_hierarchy.png">
						<p>
							This hierarchy allows your application to benefit from the following:<br>
							1) Easier development because you can define properties and methods on your base application exception
							class that can be inherited by your other application exception classes.<br>
							2) New exception classes created after your application has been deployed can derive from an existing
							exception type within the hierarchy. Existing exception handling code that catches one of the base
							classes of the new exception object will catch the new exception without any modifications to the
							existing code, interpreting it as one of the object's base classes.
						</p>
					</div>

					<div class="title">什么情况下要使用自定义类?</div>
					<div class="content closed">
						<p>As you create your hierarchy, use the following questions to help you to decide if you need to create a new exception class.</p>
						<p>
							<span class="text-strong">1) Does an exception exist for this condition?</span>
							<br>
							If an exception exists either within your current hierarchy or within the Framework, use it instead of
							creating your own exception class.
							<br>
							<span class="text-strong">2) Does a particular exception need discrete handling?</span>
							<br>
							If so, you should create an exception class to allow your code to catch the specific exception and handle
							it explicitly. This eliminates the need to catch a more generic exception and then use conditional logic to
							determine what action to take.
							<br>
							<span class="text-strong">3) Do you need specific behavior or additional information for a particular exception?</span>
							<br>
							If so, you can use a new application exception class to include additional information or functionality to
							suit a specific need.
						</p>
					</div>

					<div class="title">范例</div>
					<div class="content closed">
						<p class="text-strong">Creating a Base Application Exception Class</p>
						<p>
							Your application should have a single base exception class that derives from ApplicationException. This class
							serves as the base class for all of your application's exception classes.
						</p>
						<p>
							You should add fields to this base class to capture specific information, such as the date and time the exception
							occurred, the machine name, and so on. This encapsulates the common exception details into the single base
							class and makes this information available to your exception classes through inheritance.
						</p>

						<pre class="prettyprint linenums">
<code>
public class YourBaseApplicationException : ApplicationException
{
    // Default constructor
    public YourBaseApplicationException()
    { }

    // Constructor accepting a single string message
    public YourBaseApplicationException(string message)
        : base(message)
    { }

    // Constructor accepting a string message and an inner exception which will be wrapped by this custom exception class
    public YourBaseApplicationException(string message, Exception inner)
        : base(message, inner)
    { }

    protected YourBaseApplicationException(SerializationInfo info, StreamingContext context)
        : base(info, context)
    { }
}
</code>
						</pre>	

						<p class="text-strong">Remoting Custom Exceptions</p>
						<p>
							The Exception class implements the ISerializable interface, allowing it to manage its own serialization. To
							allow your exceptions to be marshaled across remoting boundaries, you need to attribute your class with the
							[Serializable] attribute and include the additional constructor shown below.
						</p>
						<pre class="prettyprint linenums">
<code>
protected YourBaseApplicationException(SerializationInfo info, StreamingContext context)
    : base(info, context)
{ }
</code>
						</pre>
						<p>
							If your exceptions add fields to the base ApplicationException class, you will need to persist these values
							programmatically into the serialized data stream. This can be done by overriding the GetObjectData method
							and adding these values to the SerializationInfo object as shown below.
						</p>
						<pre class="prettyprint linenums">
<code>
[Serializable]
public class ExampleException : ApplicationException
{
    public ExampleException()
        : base()
    { }

    public ExampleException(string message)
        : base(message)
    { }

    public ExampleException(string message, Exception inner) :
        base(message, inner)
    { }

    protected ExampleException(SerializationInfo info, StreamingContext context) :
        base(info, context)
    {
        m_strMachineName = info.GetString("m_strMachineName");
    }

    public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        info.AddValue("m_strMachineName", m_strMachineName, typeof(String));
        base.GetObjectData(info, context);
    }

    private string m_strMachineName = Environment.MachineName;
    public string MachineName
    {
        get { return m_strMachineName; }
        set { m_strMachineName = value; }
    }
}
</code>
						</pre>
						<p>
							The values can be retrieved from the SerializationInfo object in the constructor of your exception object using
							info.GetValue or one of the Get methods of the SerializationInfo object (such as the GetString method
							shown above). Your custom exceptions should be able to maintain their state as they are marshaled across local
							and remote boundaries. Even if your application does not currently span remoting boundaries, providing
							serialization support ensures that exception information will not be lost if your application is later modified to do
							so. If you do not programmatically serialize your exception's custom values, they will not be set properly when
							they are deserialized at the client. Providing serialization support also allows your application to serialize all the
							information about your exception and store it for logging purposes.
						</p>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="title">捕捉异常</div>
	<div class="content closed">
		<img src="__ROOT__/static/image/cs/exception_handling_process.png">
	</div>


	<div class="title">其他</div>
	<div class="content closed">

	</div>

	<hr>

	<div class="title">如何处理异常?</div>
	<div class="content closed">
		<img src="__ROOT__/static/image/cs/exception_handling_process.png">
	</div>

	<div class="title">无法处理的异常怎么办?</div>
	<div class="content closed">
		<p>Figure below shows the process your application
			should perform when the exception is propagated to the last point or boundary at which your application can
			handle the exception before returning to the user.</p>
		<img src="__ROOT__/static/image/cs/processing_of_unhandled_exception.png">
	</div>

	<div class="title">什么情况下需要捕捉异常?</div>
	<div class="content closed">
		<p class="text-strong">结构化异常处理</p>
		<pre class="prettyprint linenums">
<code>
try {
    // 这里放置可能会出现异常的代码
} catch (SomeException ex) {
    //  发生这种类型的异常时, 会调到这里执行
} finally {
    // 不管有没有异常, 这里的代码都会执行
}
</code>
		</pre>

		<p class="text-strong">什么情况下要捕捉异常?</p>
		<p>You should only catch exceptions when you need to specifically perform any of the following actions:</p>
		<p>
			1) Gather information for logging <br>
			2) Add any relevant information to the exception <br>
			3) Execute cleanup code <br>
			4) Attempt to recover
		</p>
		<p>
			If a particular method does not need to perform any of these actions, it should not catch the exception; rather, it
			should allow it to propagate back up the call stack. <br>
			This keeps your code clean and explicit as you only catch the
			exceptions that need to be handled within the scope of a particular method and allow all others to continue to
			propagate.
		</p>
	</div>



	<div class="title">如何传播异常?</div>
	<div class="content closed">
		<pre class="prettyprint linenums">
<code>
try {
    // Some code that could throw an exception.
} catch (TypeAException e) {
    throw;
    // 方法1: Catch and rethrow the exception
    // With this approach, you catch and react to the exception, and clean up or perform any other required processing within the scope of the current method. 
    // If you cannot recover from the exception, you rethrow the same exception to your caller.
} catch (TypeBException e) {
    throw (new TypecException(Message, e));
    // 方法2: Catch, wrap, and throw the wrapped exception
    // With this approach, you catch the exception, which allows you to react to it, clean up, or perform any other required processing within the scope of the current method. 
    // If you cannot recover, wrap the exception in a new exception, and throw the new exception back to the caller. 
    
    // As an exception propagates up the call stack, the exception type becomes less relevant. When an exception is wrapped, a more relevant exception can be returned to the caller. 
    // For example, consider a hypothetical method called LoadUserInfo. This method may load a user's information from a file that is assumed to exist when the method tries to access it. 
    // If the file does not exist, a FileNotFoundException is thrown, which has meaning within the context of the LoadUserInfo method.
    // However, as the exception propagates back up the call stack—for example, to a LogonUser method—a FileNotFoundException exception does not provide any valuable information. 
    // If you wrap the FileNotFoundException in a custom exception class—for example, one called FailedToLoadUserInfoException—and throw the wrapper exception, it provides more information and is more relevant to the calling LogonUser method.
    // You can then catch the FailedToLoadUserInfoException exception in the LogonUser method and react to that particular exception type rather than having to catch the FileNotFoundException, which is an implementation detail of another method.
} finally {
    // Code that gets executed regardless of whether an exception was thrown.
}

// 方法3: Let the exception propagate automatically
// With this approach, you do nothing and deliberately ignore the exception. This causes the control to move immediately from the current code block up the call stack until a catch block with a filter that matches the exception type is found.
</code>
		</pre>
	</div>



	<div class="title">未捕捉的异常怎么处理?</div>
	<div class="content closed">
		<p>流程控制中有记录...</p>
	</div>

	<div class="title">如何提示异常信息?</div>
	<div class="content closed">
		<p class="text-strong">什么样的Audience提供什么样的信息</p>
		<table class="table table-bordered table-sm">
			<tbody>
				<tr>
					<th>Audience</th>
					<th>Required Information</th>
				</tr>
				<tr>
					<td>End users</td>
					<td>
						An indication of whether the request succeeded.
						A well presented message indicating what went wrong.
						Instructions telling them what they should do to rectify
						the problem
					</td>
				</tr>
				<tr>
					<td>Application developers</td>
					<td>
						Date and time that the exception occurred.
						The precise location of the source of the exception.
						Exactly which exception occurred.
						Information associated with the exception and the state
						of the system when the exception occurred.	
					</td>
				</tr>
				<tr>
					<td>Operators</td>
					<td>
						Date and time the exception occurred.
						The precise location of the source of the exception.
						Exactly which exception occurred.
						What resources should be notified and what information
						needs to be given.
						The exception type indicating whether it relates to an
						operational or development issue.	
					</td>
				</tr>
			</tbody>
		</table>

		<p class="text-strong">Exception Information to Capture</p>
		<table class="table table-bordered table-sm">
			<tbody>
				<tr>
					<th>Data</th>
					<th>Source</th>
				</tr>
				<tr>
					<td>Date and time of exception</td>
					<td>DateTime.Now</td>
				</tr>
				<tr>
					<td>Machine name</td>
					<td>Environment.MachineName</td>
				</tr>
				<tr>
					<td>Exception source</td>
					<td>Exception.Source</td>
				</tr>
				<tr>
					<td>Exception type</td>
					<td>Type.FullName obtained from Object.GetType</td>
				</tr>
				<tr>
					<td>Exception message</td>
					<td>Exception.Message</td>
				</tr>
				<tr>
					<td>Exception stack trace</td>
					<td>Exception.StackTrace - this trace starts at the point the exception is thrown and is populated as it propagates up the call stack.</td>
				</tr>
				<tr>
					<td>Call stack</td>
					<td>Enviroment.StackTrace - the complete call stack.</td>
				</tr>
				<tr>
					<td>Application domain name</td>
					<td>AppDomain.FriendlyName</td>
				</tr>
				<tr>
					<td>Assembly name</td>
					<td>AsssemblyName.FullName, in the System.Reflection namespace</td>
				</tr>
				<tr>
					<td>Assembly version</td>
					<td>Included in the AssemblyName.FullName</td>
				</tr>
				<tr>
					<td>Thread ID</td>
					<td>AppDomain.GetCurrentThreadId</td>
				</tr>
				<tr>
					<td>Thread user</td>
					<td>Thread.CurrentPrincipal in the System.Threading namespace</td>
				</tr>
			</tbody>
		</table>	
	</div>

	<div class="title">Application Instrumentation</div>
	<div class="content open">
		<p>TBD...</p>
	</div>

	<div class="title">Specific Technology Considerations</div>
	<div class="content closed">
		<p>
			This section examines some specific considerations for exception management when combined with certain .NET
			technologies.
		</p>	
		<p class="text-strong">Interoperability</p>
		<p>
			The runtime provides a variety of interoperability features that allow your managed and unmanaged code to
			work together. This also applies to exception handling. When a COM client calls a managed class that throws an
			exception, the runtime catches and translates it into an HRESULT that can be understood by the unmanaged
			COM code. Similarly, if a COM component returns a failed HRESULT to managed code, the runtime translates an
			exception from the HRESULT and incorporates any additional information provided by the COM IErrorInfo
			interface into the exception object. If the runtime does not recognize the HRESULT, it returns a generic
			COMException object with its ErrorCode property set to the unrecognized HRESULT value.	
		</p>
		<p>
			Many of the .NET Framework class library exceptions return new HRESULT values to COM components. This
			causes existing COM code not to recognize the HRESULTs. If your COM code takes some action based on certain
			failed HRESULTs, you should change the HRESULT value of the exception before propagating it to your COM
			code. The HResult property of the exception object represents the HRESULT value returned to unmanaged
			code. It is a read/write property and can be set to any value to ensure the correct operation of your COM code.
			In addition, any application exceptions you create that interact with unmanaged COM code should override the
			HResult property and default the value to an HRESULT value that accurately represents the exception condition.	
		</p>

		<p class="text-strong">Localization</p>
		<p>
			Localization is required to provide the right information to the right audience. Your application should provide
			localization to ensure that your information is presented in a format that your audiences can understand. .NET
			provides mechanisms, such as assembly cultures and satellite assemblies, to integrate localization features into
			your application.
		</p>
		<p>
			<span class="text-strong">Cultures</span><br>
			A culture is part of the assembly identity and is involved in the binding process. For example, an
			assembly could be strictly developed for a Spanish audience.<br>
			<span class="text-strong">Satellite Assemblies</span><br>
			These are resource-only assemblies that do not contain common intermediate language (CIL) code.
			Satellite assemblies can specify a culture that accurately reflects the culture of the resources placed in
			the assembly
		</p>
	</div>

	<div class="title">异常 vs 错误代码</div>
	<div class="content closed">
		<p>错误代码: 出现错误时, 如果程式没有处理, 很难发现; 需要知道不同错误代码的含义.</p>
		<p>异常: 出现异常时, 如果程式没有处理, 默认会弹出异常对话框; 通过Message属性可以获取异常的详细说明; 通过StackTrace可以知道哪一行代码出错; 抛出异常时对程式性能有影响.</p>
		<p>异常抛出一般用于处理未预料到的错误, 比如内存异常, 常见的错误可以使用错误代码方式. int.TryParse()就比int.Parse()函数友好..</p>
	</div>

</div>

<hr>
<p>
	参考: <br>
	Exception Management Architechture Guide.pdf
</p>

{include file="template/footer" /}