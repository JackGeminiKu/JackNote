{include file="template/header" title="C# 异常管理" /}

<div class="list list-number">
	<div class="title">异常处理原则</div>
	<div class="content open">
		<p>
			1 如果你不能处理异常，不要捕获该异常。<br>
			2 如果要捕获，应在离异常源近的地方捕获它。<br>
			3 不要吞没你捕获的异常, 就是捕获的异常，但是什么也不做。<br>
			4 除非你要重新抛出异常，否则把它log起来。<br>
			5 当一个异常被重新包装，然后重新抛出的时候，不要打印statck trace。<br>
			6 用自定义的异常类，不要每次需要抛出异常的时候都抛出java.lang.Exception。方法的调用者可以通过throws知道有哪些异常需要处理--所以它是自我描述的。<br>
			7 如果你编写业务逻辑，对于终端用户无法修复的错误，系统应该抛出非检查的异常（unchecked exception）；如果你编写一个第三方的包给其他的开发人员用，对于不可修复的错误要用需要检查的异常（checked exception）。<br>
			8 绝对不要因为写throws语句会让你用起来不舒服，而不声明需要检查的异常。<br>
			9 应用级别的错误或不可修复的系统异常用非检查的异常（unchecked exception）抛出。<br>
			*（注意是错误，意味着不可修复，比如配置文件错误）<br>
			10 根据异常的粒度组织你的方法.<br>
		</p>
	</div>

    <div class="title">出错处理三大问题</div>
    <div class="content open">
		<p>
			1) 出错处理机制: 异常或者返回值(不良代码, true/false, null...)
		<p>
			2) 是否要log不良信息? 怎么log?
		</p>

		<p>
			3) 时候要提示给用户? 怎么提示?
		</p> 
    </div>

    <div class="title">异常 vs 错误代码</div>
    <div class="content open">
		<p>错误代码: 出现错误时, 如果程式没有处理, 很难发现; 需要知道不同错误代码的含义.</p>
		<p>异常: 出现异常时, 如果程式没有处理, 默认会弹出异常对话框; 通过Message属性可以获取异常的详细说明; 通过StackTrace可以知道哪一行代码出错; 抛出异常时对程式性能有影响.</p>
		<p>异常抛出一般用于处理未预料到的错误, 比如内存异常, 常见的错误可以使用错误代码方式. int.TryParse()就比int.Parse()函数友好..</p>
    </div>

	<div class="title">异常类型层级</div>
	<div class="content closed">
		<p>
			Exception是所有异常的基类, 它有两个主要的子类: <br>
			1) SystemException <br>
			2) ApplicationException <br>
		</p>
		<p>
			SystemException
			ApplicationException是应用程序相关异常的基类, 用户自定义的类应该继承自这个类.
		</p>
	</div>

	<div class="title">如何处理异常?</div>
	<div class="content closed">
		<img src="__ROOT__/static/image/cs/exception_handling_process.png">

	</div>

	<div class="title">无法处理的异常怎么办?</div>
	<div class="content closed">
		<p>Figure below shows the process your application
			should perform when the exception is propagated to the last point or boundary at which your application can
			handle the exception before returning to the user.</p>
		<img src="__ROOT__/static/image/cs/processing_of_unhandled_exception.png">
	</div>

	<div class="title">如何捕捉异常?</div>
	<div class="content closed">
		<p class="text-strong">结构化异常处理</p>
		<pre class="prettyprint linenums">
<code>
try {
    // 这里放置可能会出现异常的代码
} catch (SomeException ex) {
    //  发生这种类型的异常时, 会调到这里执行
} finally {
    // 不管有没有异常, 这里的代码都会执行
}
</code>
		</pre>

		<p class="text-strong">什么情况下要捕捉异常?</p>
		<p>You should only catch exceptions when you need to specifically perform any of the following actions:</p>
		<p>
			1) Gather information for logging <br>
			2) Add any relevant information to the exception <br>
			3) Execute cleanup code <br>
			4) Attempt to recover
		</p>
		<p>
			If a particular method does not need to perform any of these actions, it should not catch the exception; rather, it
			should allow it to propagate back up the call stack. This keeps your code clean and explicit as you only catch the
			exceptions that need to be handled within the scope of a particular method and allow all others to continue to
			propagate.
		</p>
	</div>

	<div class="title">什么时候可以抛出异常?</div>
	<div class="content closed">
		<p>
			You should only throw exceptions when a condition outside of your code's assumptions occurs. In other words,
			you should not use exceptions as a means to provide your intended functionality. 
		</p>
		<p>
			For example, a user might
			enter an invalid user name or password while logging on to an application. While this is not a successful logon, it
			should be a valid and expected result, and therefore should not throw an exception. </p>
		<p>
			However, an exception
			should be generated if an unexpected condition occurs, such as an unavailable user database. Throwing
			exceptions is more expensive than simply returning a result to a caller. Therefore they should not be used to
			control the normal flow of execution through your code. In addition, excessive use of exceptions can create
			unreadable and unmanageable code.	
		</p>
	</div>

	<div class="title">什么情况下使用InnerException?</div>
	<div class="content closed">
		<p>
			In certain scenarios, an exception you throw may be caught by the runtime and an exception of another type
			might be thrown up the call stack in place of the original. 
		</p> 
		<p>
			For example, consider the case in which you call the
			Sort method on an ArrayList of your objects. If one of your objects throws an exception in the CompareTo
			method of its IComparable interface, the exception is caught by the runtime and a
			System.InvalidOperationException exception is thrown to the code that calls the Sort method. 
		</p>
		<p>
			In addition,
			any exception thrown by a method that you invoke through reflection will be caught by the runtime and a
			System.Reflection.TargetInvocationException will be thrown to your code. 
		</p>
		<p>
			In these scenarios your original
			exception is not lost. It is set as the InnerException of the exception thrown by the runtime. 
			Situations like this can occur in
			a number of scenarios. You should be aware of this and test your applications thoroughly to minimize the impact
			of these scenarios
		</p>
	</div>

	<div class="title">如何传播异常?</div>
	<div class="content closed">
		<pre class="prettyprint linenums">
<code>
try {
    // Some code that could throw an exception.
} catch (TypeAException e) {
    // 方法1: Catch and rethrow the exception

    // With this approach, you catch and react to the exception, and clean up or perform any other 
    // required processing within the scope of the current method. 

    // If you cannot recover from the exception, you rethrow the same exception to your caller.
    throw;
} catch (TypeBException e) {
    // 方法2: Catch, wrap, and throw the wrapped exception

    // As an exception propagates up the call stack, the exception type becomes less relevant. When an
    // exception is wrapped, a more relevant exception can be returned to the caller. 
    // For example, consider a hypothetical method called LoadUserInfo. This method may load a user's information
    // from a file that is assumed to exist when the method tries to access it. If the file does not exist, a
    // FileNotFoundException is thrown, which has meaning within the context of the LoadUserInfo method.
    // However, as the exception propagates back up the call stack—for example, to a LogonUser method—a
    // FileNotFoundException exception does not provide any valuable information. If you wrap the
    // FileNotFoundException in a custom exception class (discussed later in this document)—for example, one
    // called FailedToLoadUserInfoException—and throw the wrapper exception, it provides more information and
    // is more relevant to the calling LogonUser method. You can then catch the FailedToLoadUserInfoException
    // exception in the LogonUser method and react to that particular exception type rather than having to catch the
    // FileNotFoundException, which is an implementation detail of another method.

    // With this approach, you catch the exception, which allows you to react to it, clean up, or
    // perform any other required processing within the scope of the current method. 
    // If you cannot recover, wrap the exception in a new exception, and throw the new exception back to the caller. 
    throw (new TypecException(Message, e));
} finally {
    // Code that gets executed regardless of whether an exception was thrown.
}

// 方法3: Let the exception propagate automatically

// With this approach, you do nothing and deliberately ignore the exception. This causes the control to
// move immediately from the current code block up the call stack until a catch block with a filter that
// matches the exception type is found.
</code>
		</pre>
	</div>

	<div class="title">自定义异常</div>
	<div class="content closed">
		<div class="list list-number">
			<div class="title">自定义类层次</div>
			<div class="content closed">
				<p>
					The .NET Framework is a type-based system that relies on the exception type for identification, rather than
					using method return codes such as HRESULTs. You should establish a custom hierarchy of application-specific
					exception classes that inherit from ApplicationException, as illustrated in Figure below.
				</p>
				<img src="__ROOT__/static/image/cs/application_exception_hierarchy.png">
				<p>
					This hierarchy allows your application to benefit from the following:<br>
					1) Easier development because you can define properties and methods on your base application exception
					class that can be inherited by your other application exception classes.<br>
					2) New exception classes created after your application has been deployed can derive from an existing
					exception type within the hierarchy. Existing exception handling code that catches one of the base
					classes of the new exception object will catch the new exception without any modifications to the
					existing code, interpreting it as one of the object's base classes.
				</p>
			</div>

			<div class="title">什么情况下要使用自定义类?</div>
			<div class="content closed">
				<p>
					The .NET Framework provides an extensive hierarchy of exception classes. If a suitable exception class is
					already provided by the .NET Framework, use it instead of creating a new class. You should only create a new
					application exception class for an exception type that you need to react to and handle within your code that is
					not already available in your application exception hierarchy or in the Framework. Most application exception
					hierarchies should be fairly flat with grouping used for organization purposes or to allow some set of application
					exceptions to inherit common properties or functionality.
				</p>
				<p>
					As you create your hierarchy, use the following questions to help you to decide if you need to create a new
					exception class.
					<br>
					<span class="text-strong">1) Does an exception exist for this condition?</span>
					<br>
					If an exception exists either within your current hierarchy or within the Framework, use it instead of
					creating your own exception class.
					<br>
					<span class="text-strong">2) Does a particular exception need discrete handling?</span>
					<br>
					If so, you should create an exception class to allow your code to catch the specific exception and handle
					it explicitly. This eliminates the need to catch a more generic exception and then use conditional logic to
					determine what action to take.
					<br>
					<span class="text-strong">3) Do you need specific behavior or additional information for a particular exception?</span>
					<br>
					If so, you can use a new application exception class to include additional information or functionality to
					suit a specific need.
				</p>
			</div>

			<div class="title">范例</div>
			<div class="content closed">
				<pre class="prettyprint linenums">
<code>
public class YourBaseApplicationException : ApplicationException
{
    // Default constructor
    public YourBaseApplicationException()
    { }

    // Constructor accepting a single string message
    public YourBaseApplicationException(string message)
        : base(message)
    { }

    // Constructor accepting a string message and an inner exception which will be wrapped by this custom exception class
    public YourBaseApplicationException(string message, Exception inner)
        : base(message, inner)
    { }

    protected YourBaseApplicationException(SerializationInfo info, StreamingContext context)
        : base(info, context)
    { }
}
</code>
				</pre>	
				<p class="text-strong">Creating a Base Application Exception Class</p>
				<p>
					Your application should have a single base exception class that derives from ApplicationException. This class
					serves as the base class for all of your application's exception classes.
				</p>
				<p>
					You should add fields to this base class to capture specific information, such as the date and time the exception
					occurred, the machine name, and so on. This encapsulates the common exception details into the single base
					class and makes this information available to your exception classes through inheritance.
				</p>

				<p class="text-strong">Remoting Custom Exceptions</p>
				<p>
					The Exception class implements the ISerializable interface, allowing it to manage its own serialization. To
					allow your exceptions to be marshaled across remoting boundaries, you need to attribute your class with the
					[Serializable] attribute and include the additional constructor shown below.
				</p>
				<pre class="prettyprint linenums">
<code>
protected YourBaseApplicationException(SerializationInfo info, StreamingContext context)
    : base(info, context)
{ }
</code>
				</pre>
				<p>
					If your exceptions add fields to the base ApplicationException class, you will need to persist these values
					programmatically into the serialized data stream. This can be done by overriding the GetObjectData method
					and adding these values to the SerializationInfo object as shown below.
				</p>
				<pre class="prettyprint linenums">
<code>
[Serializable]
public class ExampleException : ApplicationException
{
    public ExampleException()
        : base()
    { }

    public ExampleException(string message)
        : base(message)
    { }

    public ExampleException(string message, Exception inner) :
        base(message, inner)
    { }

    protected ExampleException(SerializationInfo info, StreamingContext context) :
        base(info, context)
    {
        m_strMachineName = info.GetString("m_strMachineName");
    }

    public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        info.AddValue("m_strMachineName", m_strMachineName, typeof(String));
        base.GetObjectData(info, context);
    }

    private string m_strMachineName = Environment.MachineName;
    public string MachineName
    {
        get { return m_strMachineName; }
        set { m_strMachineName = value; }
    }
}
</code>
				</pre>
				<p>
					The values can be retrieved from the SerializationInfo object in the constructor of your exception object using
					info.GetValue or one of the Get methods of the SerializationInfo object (such as the GetString method
					shown above). Your custom exceptions should be able to maintain their state as they are marshaled across local
					and remote boundaries. Even if your application does not currently span remoting boundaries, providing
					serialization support ensures that exception information will not be lost if your application is later modified to do
					so. If you do not programmatically serialize your exception's custom values, they will not be set properly when
					they are deserialized at the client. Providing serialization support also allows your application to serialize all the
					information about your exception and store it for logging purposes.
				</p>
			</div>
		</div>

		<div class="title">处理未捕捉的异常</div>
		<div class="content closed">
			<p>流程控制中有记录...</p>
		</div>

		<div class="title">收集信息</div>
		<div class="content closed">

		</div>

		<div class="titlte">Application Instrumentation</div>
		<div class="content cloesd">
			<p>TBD...</p>
		</div>

		<div class="title">Specific Technology Considerations</div>
		<div class="content closed">
			<p>TBD...</p>	
		</div>
	</div>
</div>

<hr>
<p>
	参考: <br>
	Exception Management Architechture Guide.pdf
</p>

{include file="template/footer" /}