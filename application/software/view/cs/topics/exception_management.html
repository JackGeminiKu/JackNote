{include file="template/header" title="C# 异常管理" /}

<div class="list list-number">
	<div class="title">异常处理原则</div>
	<div class="content open">
		<p>
			1 如果你不能处理异常，不要捕获该异常。<br>
			2 如果要捕获，应在离异常源近的地方捕获它。<br>
			3 不要吞没你捕获的异常, 就是捕获的异常，但是什么也不做。<br>
			4 除非你要重新抛出异常，否则把它log起来。<br>
			5 当一个异常被重新包装，然后重新抛出的时候，不要打印statck trace。<br>
			6 用自定义的异常类，不要每次需要抛出异常的时候都抛出java.lang.Exception。方法的调用者可以通过throws知道有哪些异常需要处理--所以它是自我描述的。<br>
			7 如果你编写业务逻辑，对于终端用户无法修复的错误，系统应该抛出非检查的异常（unchecked exception）；如果你编写一个第三方的包给其他的开发人员用，对于不可修复的错误要用需要检查的异常（checked exception）。<br>
			8 绝对不要因为写throws语句会让你用起来不舒服，而不声明需要检查的异常。<br>
			9 应用级别的错误或不可修复的系统异常用非检查的异常（unchecked exception）抛出。<br>
			*（注意是错误，意味着不可修复，比如配置文件错误）<br>
			10 根据异常的粒度组织你的方法.<br>
		</p>
	</div>

    <div class="title">出错处理三大问题</div>
    <div class="content open">
		<p>
			1) 出错处理机制: 异常或者返回值(不良代码, true/false, null...)
		<p>
			2) 是否要log不良信息? 怎么log?
		</p>

		<p>
			3) 时候要提示给用户? 怎么提示?
		</p> 
    </div>

    <div class="title">异常 vs 错误代码</div>
    <div class="content open">
		<p>错误代码: 出现错误时, 如果程式没有处理, 很难发现; 需要知道不同错误代码的含义.</p>
		<p>异常: 出现异常时, 如果程式没有处理, 默认会弹出异常对话框; 通过Message属性可以获取异常的详细说明; 通过StackTrace可以知道哪一行代码出错; 抛出异常时对程式性能有影响.</p>
		<p>异常抛出一般用于处理未预料到的错误, 比如内存异常, 常见的错误可以使用错误代码方式. int.TryParse()就比int.Parse()函数友好..</p>
    </div>

	<div class="title">异常类型层级</div>
	<div class="content closed">
		<p>
			Exception是所有异常的基类, 它有两个主要的子类: <br>
			1) SystemException <br>
			2) ApplicationException <br>
		</p>
		<p>
			SystemException
			ApplicationException是应用程序相关异常的基类, 用户自定义的类应该继承自这个类.
		</p>
	</div>

	<div class="title">如何处理异常?</div>
	<div class="content closed">
		<img src="__ROOT__/static/image/cs/exception_handling_process.png">

	</div>

	<div class="title">无法处理的异常怎么办?</div>
	<div class="content closed">
		<p>Figure below shows the process your application
			should perform when the exception is propagated to the last point or boundary at which your application can
			handle the exception before returning to the user.</p>
		<img src="__ROOT__/static/image/cs/processing_of_unhandled_exception.png">
	</div>

	<div class="title">如何捕捉异常?</div>
	<div class="content closed">
		<p class="text-strong">结构化异常处理</p>
		<pre class="prettyprint linenums">
<code>
try {
    // 这里放置可能会出现异常的代码
} catch (SomeException ex) {
    //  发生这种类型的异常时, 会调到这里执行
} finally {
    // 不管有没有异常, 这里的代码都会执行
}
</code>
		</pre>

		<p class="text-strong">什么情况下要捕捉异常?</p>
		<p>You should only catch exceptions when you need to specifically perform any of the following actions:</p>
		<p>
			1) Gather information for logging <br>
			2) Add any relevant information to the exception <br>
			3) Execute cleanup code <br>
			4) Attempt to recover
		</p>
		<p>
			If a particular method does not need to perform any of these actions, it should not catch the exception; rather, it
			should allow it to propagate back up the call stack. This keeps your code clean and explicit as you only catch the
			exceptions that need to be handled within the scope of a particular method and allow all others to continue to
			propagate.
		</p>
	</div>

	<div class="title">什么时候可以抛出异常?</div>
	<div class="content closed">
		<p>
			You should only throw exceptions when a condition outside of your code's assumptions occurs. In other words,
			you should not use exceptions as a means to provide your intended functionality. 
		</p>
		<p>
			For example, a user might
			enter an invalid user name or password while logging on to an application. While this is not a successful logon, it
			should be a valid and expected result, and therefore should not throw an exception. </p>
		<p>
			However, an exception
			should be generated if an unexpected condition occurs, such as an unavailable user database. Throwing
			exceptions is more expensive than simply returning a result to a caller. Therefore they should not be used to
			control the normal flow of execution through your code. In addition, excessive use of exceptions can create
			unreadable and unmanageable code.	
		</p>
	</div>

	<div class="title">什么情况下使用InnerException?</div>
	<div class="content closed">
		<p>
			In certain scenarios, an exception you throw may be caught by the runtime and an exception of another type
			might be thrown up the call stack in place of the original. 
		</p> 
		<p>
			For example, consider the case in which you call the
			Sort method on an ArrayList of your objects. If one of your objects throws an exception in the CompareTo
			method of its IComparable interface, the exception is caught by the runtime and a
			System.InvalidOperationException exception is thrown to the code that calls the Sort method. 
		</p>
		<p>
			In addition,
			any exception thrown by a method that you invoke through reflection will be caught by the runtime and a
			System.Reflection.TargetInvocationException will be thrown to your code. 
		</p>
		<p>
			In these scenarios your original
			exception is not lost. It is set as the InnerException of the exception thrown by the runtime. 
			Situations like this can occur in
			a number of scenarios. You should be aware of this and test your applications thoroughly to minimize the impact
			of these scenarios
		</p>
	</div>

	<div class="title">如何传播异常?</div>
	<div class="content closed">
		<pre class="prettyprint linenums">
<code>
try {
    // Some code that could throw an exception.
} catch (TypeAException e) {
    // 方法1: Catch and rethrow the exception

    // With this approach, you catch and react to the exception, and clean up or perform any other 
    // required processing within the scope of the current method. 

    // If you cannot recover from the exception, you rethrow the same exception to your caller.
    throw;
} catch (TypeBException e) {
    // 方法2: Catch, wrap, and throw the wrapped exception

    // As an exception propagates up the call stack, the exception type becomes less relevant. When an
    // exception is wrapped, a more relevant exception can be returned to the caller. 
    // For example, consider a hypothetical method called LoadUserInfo. This method may load a user's information
    // from a file that is assumed to exist when the method tries to access it. If the file does not exist, a
    // FileNotFoundException is thrown, which has meaning within the context of the LoadUserInfo method.
    // However, as the exception propagates back up the call stack—for example, to a LogonUser method—a
    // FileNotFoundException exception does not provide any valuable information. If you wrap the
    // FileNotFoundException in a custom exception class (discussed later in this document)—for example, one
    // called FailedToLoadUserInfoException—and throw the wrapper exception, it provides more information and
    // is more relevant to the calling LogonUser method. You can then catch the FailedToLoadUserInfoException
    // exception in the LogonUser method and react to that particular exception type rather than having to catch the
    // FileNotFoundException, which is an implementation detail of another method.

    // With this approach, you catch the exception, which allows you to react to it, clean up, or
    // perform any other required processing within the scope of the current method. 
    // If you cannot recover, wrap the exception in a new exception, and throw the new exception back to the caller. 
    throw (new TypecException(Message, e));
} finally {
    // Code that gets executed regardless of whether an exception was thrown.
}

// 方法3: Let the exception propagate automatically

// With this approach, you do nothing and deliberately ignore the exception. This causes the control to
// move immediately from the current code block up the call stack until a catch block with a filter that
// matches the exception type is found.
</code>
		</pre>
	</div>
</div>

<hr>
<p>
	参考: <br>
	<a href="https://blog.csdn.net/wangxi1240/article/details/95855">Exception Management Architecture Guide 2.0</a>
</p>

{include file="template/footer" /}