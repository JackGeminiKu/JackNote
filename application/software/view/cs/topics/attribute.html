{include file="template/header" title="C# 属性" /}

<div class="list list-number">
    <div class="title">内置属性</div>
    <div class="content open">
		<div class="list list-number">
			<div class="title">程序集属性</div>
			<div class="content closed">
				<pre class="prettyprint linenums">
<code>
[assembly: AssemblyTitle("DatabaseAttributes")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("DatabaseAttributes")]
[assembly: AssemblyCopyright("Copyright @ Microsoft 2004")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: AssemblyVersion("1.0.*")]
</code>
				</pre>
				<p>
					如上所示, 有许多以"[assembly:"开头的代码行, 它们就是属性定义. 在编译这个文件时, 定义了的任何属性都保存在最后的程序集中, 这个过程称为"picking".
				</p>
				<p>
					在AssemblyInfo.cs的代码段中, 使用了术语AssebmlyTitle, 但在IL代码中, 则使用AssemblyTitleAttribute. C#编译器会查找一个属性类AssemblyTitle, 如果没有找到, 就在该词的后面加上Attribute, 并在此搜索. 所有无论是输入了完整的类名, 还是忽略了最后的Attribute, 都会得到相同的代码.
				</p>
				<p>
					程序集清单中定义的属性声明看起来像是一个对象及其构造函数, 方括号中的字节是传递给构造函数的参数.
				</p>
			</div>

			<div class="title">条件编译</div>
			<div class="content closed">
				<pre class="prettyprint linenums">
<code>
using System;
using System.Diagnostics;
 
namespace TestConditional
{
    class Program
    {
        static void Main(string[] args)
        {
            Program.DebugOnly();
        }
 
        // This method is atributed, and will ONLY be included in
        // the emitted code if the DEBUG symbol is defined when
        // the program is compiled
        [Conditional("DEBUG")]
        public static void DebugOnly()
        {
            Console.WriteLine("This string only displays in Debug");
        }
    }
}
</code>
				</pre>

				<p>
					这是最常用的属性之一, 因为它允许在编译时, 根据符号的定义包含或不包含代码块.如果没有给出某个方法的符号, Conditional属性将禁止调用该方法. 
				</p>
				<p>
					定义符号有两种方法:<br>
					1) >csc /define:DEBUG conditional.cs<br>
					2) 在项目属性对话框中, 选择Build选项, 在Conditional compilation symbols处进行设置.	
				</p>
				<p>
					注意:<br>
					1) 如果在Visual Studio 2005中编译一个调试版程序, DEBUG符号就会自动设置.<br>
					2) Conditional属性只能用于无返回值的方法, 否则, 删除调用就意味着没有返回值, 但可以把方法设置为带有out或ref参数, 变量仍保留为原始值.
				</p>
			</div>

			<div class="title">过时代码</div>
			<div class="content closed">
				<p>
					Obsolete属性可以把类, 方法或程序集中的其他项标记为不再使用. 这个属性很有用的, 在开发一系列类的过程中, 会有一些类, 方法或属性被取代, 这是不可避免的. 这个属性可以让代码的使用者最终抛弃某个功能.
				</p>
				<p class="text-strong">编译警告</p>
				<pre class="prettyprint linenums">
<code>
[Obsolete("CodeInCSharp instead.")]
public void CodeInCPlusPlus()
{
    // 编译时会显示一个警告信息, 告诉他们有一个更新的方法, 通知用户CodeInCSharp()的存在
}
</code>
				</pre>

				<p class="text-strong">编译出错</p>
				<pre class="prettyprint linenums">
<code>
[Obsolete("You must use CodeInCSharp instead.", true)]
public void CodeInCPlusPlus()
{
    // 在用户试图编译这个方法时, 编译器会产生一个错误, 暂停编译, 提示用户You must use CodeInCSharp instead.
}
</code>
				</pre>
			</div>

			<div class="title">串行化</div>
			<div class="content closed">
				<p>
					在运行时接收到串行化一个对象的请求时, 就会检查对象是否实现ISerializable接口, 如果没有实现该接口, 就检查该类是否有Serializable属性. 如果类上有Serializable属性, .NET就使用反射获取所有的实例数据, 包括公共, 受保护的, 私有数据, 并把这些数据存储为对象的表示方式. 并行化是这个过程的逆过程, 数据从存储介质中读取出来, 并赋给类的实例变量.
				</p>
				<pre class="prettyprint linenums">
<code>
[Serializable]                  // 该类支持串行化
public class Person
{
    public Person() { }
    public int Age;
 
    [NonSerialized]              // 该成员不会被串行化
    public int WeightInPounds;
}
</code>
				</pre>
				<p>如果还要对对象串口化的方式进行更多的控制, 可以执行ISerializable接口, 这是一个高级论题, 这里不作讨论.</p>
			</div>

			<div class="title">延迟标记程序集</div>
			<div class="content closed">
				<p>.NET Framework还允许给程序集加上"延迟标记"属性, 即可以在GAC中注册它, 以便没有私有密钥时测试它们.</p>
				<p>
					使用延迟标记的一种场合是开发商用软件. 在将程序集销售给客户之前, 都需要用公司的私有密钥标记, 所以当编译程序集时, 应在GAC中注册它之前引用密钥文件. 但是, 许多组织都不希望它们的私有密钥出现在每个开发人员的机器上. 因此运行时允许部分地标记程序集, 变换几个位置, 使程序集可以在GAC中注册. 在全部测试完毕后, 就可以由拥有私有密钥文件的人来标记它.这可以是QA部门, 一个或多个可信任的人或市场部门.
				</p>	

				<p>延迟标记程序集步骤</p>
				<div class="list list-number">
					<div class="title">生成秘钥文件</div>
					<div class="content open">
						<pre class="prettyprint linenums">
<code>
>sn -k Company.Key    // 这个密钥文件包含公共密钥和私有密钥:
</code>
						</pre>
					</div>

					<div class="title">生成公钥文件</div>
					<div class="content open">
						<pre class="prettyprint linenums">
<code>
>sn -p Company.Key Company.Public    // 这个公共密钥文件可以复制到所有的机器上, 不需要保密, 但私有密钥文件需要保密. 
</code>
						</pre>
					</div>

					<div class="title">获取公钥记号</div>
					<div class="content open">
						<p>
							公共密钥记号基本上是公共密钥的一个缩写版本, 在注册程序集时使用它. 可以用下述两种方式获取该记号:<br>
							(1) 从公共密钥文件本身获取: >sn -t Company.Public<br>
							(2) 从使用该密钥标记的任何程序集中获取: >sn -T &lt;assembly>
						</p>
					</div>

					<div class="title">延迟标记程序集</div>
					<div class="content open">
						<pre class="prettyprint linenums">
<code>
[assembly: AssemblyKeyFile("Company.Public")]
[assembly: AssemblyDelaySign(true)]
public class DelayedSigning
{
    public DelayedSigning()
    {
 
    }
}
</code>
						</pre>
						<p>
							AssemblyKeyFile属性定义了应在哪个文件中查找密钥. 该文件既可以是公共密钥文件, 也可以是由能信任的人建立的, 包含公共密钥和私有密钥的文件.
						</p>
						<p>
							AssemblyDelaySign属性定义了程序集时完整标记(false)了, 还是做了延迟标记(true).
						</p>
						<p>
							除此之外, 还可以修改AssemblyInfo.cs文件, 定义AssemblyDelaySing和AssemblyKeyFile属性.
						</p>
						<p>注意: 还可以在VS 2005的项目属性窗口Signing中设置密钥文件和延迟标记选项.</p>
					</div>

					<div class="title">在GAC中注册</div>
					<div class="content open">
						<p>至此, 运行该程序集, 会得到如下图所示的错误.</p>
						<img src="__ROOT__/static/image/cs/delay_sign.png">						
						<p>
							这是因为此时程序集只进行了部分标记, 在默认情况下, GAC和VS2005只接受有完整强名的程序集. 但对于延迟标记的程序集, 可以使用sn实用程序指示GAC跳过强名的验证.<br>
							>sn -Vr *,34AAA4146EE01E4A<br>
							这将只是GAC允许注册公共密钥记号为34AAA4146EE01E4A4A的程序集, 现在就可以成功地把程序集安装到GAC上了. 
						</p>
						<p>
							在为程序集添加验证项时, 不需要使用公共密钥值, 可以使用下述命令, 指定注册的所有程序集:<br>
							>sn -Vr *
						</p>
						<p>
							也可以通过输入程序集的完整名称来指定他:<br>
							>sn -Vr DelaySign.dll
						</p>	
						<p>
							这些数据会永远保存在Verification Skip Table中, 这是一个存储在磁盘上的文件. 要得到Verification Skip Table中的项列表, 应键入下述命令(这些命令区分大小写):<br>
							>sn -Vl
						</p>	
						<p class="text-strong">总结</p>
						<p>
							未标记程序集(没有定义密钥文件的程序集): 直接运行<br>
							完全标记程序集(包含公共密钥和私有密钥对的程序集): 直接运行<br>
							部分标记程序集(只包含公共密钥的程序集): 跳过验证
						</p>
					</div>

					<div class="title">完整的强名</div>
					<div class="content open">
						<p>
							这个过程的最后一项是把公共密钥和私有密钥编译到程序集中, 带有这两项的程序集被称为有完整的强名, 可以在GAC中注册, 且不必跳过验证项:<br>
							>sn -R DelaySing.dll Company.Key    // 重新标记程序集, 并添加私有密钥部分
						</p>
					</div>
				</div>	
			</div>
		</div>
    </div>

    <div class="title">自定义属性</div>
    <div class="content closed">
		<p>1) 创建一个派生自System.Attribute的类</p>
		<p>2) 创建属性的构造函数, 属性的构造函数只能包含在编译时解析的类型, 例如字符串和整数</p>
		<p>3) 属性设置</p>
		<div>
			① AttributeTargets: 定义了属性可以在什么地方使用, 使用or运算符(|)可以把这些成员合并起来.<br>
			<table class="table table-bordered table-sm w-25">
				<tbody>
					<tr>
						<th>AttributeTargets值</th>
						<th>描述</th>
					</tr>
					<tr>
						<td>All</td>
						<td>属性在程序集的任何地方都有效</td>
					</tr>
					<tr>
						<td>Assembly</td>
						<td>属性在程序集上有效</td>
					</tr>
					<tr>
						<td>Class</td>
						<td>属性在类定义上有效</td>
					</tr>
					<tr>
						<td>Contructor</td>
						<td>属性仅在类的构造函数中有效</td>
					</tr>
					<tr>
						<td>Delegate</td>
						<td>属性仅在委托中有效</td>
					</tr>
					<tr>
						<td>Enum</td>
						<td>属性可以添加到枚举值中</td>
					</tr>
					<tr>
						<td>Event</td>
						<td>属性在事件定义上有效</td>
					</tr>
					<tr>
						<td>Filed</td>
						<td>属性可以在放在字段上</td>
					</tr>
					<tr>
						<td>Interface</td>
						<td>属性在接口上有效</td>
					</tr>
					<tr>
						<td>Method</td>
						<td>属性在方法上有效</td>
					</tr>
					<tr>
						<td>Module</td>
						<td>属性在模块中有效</td>
					</tr>
					<tr>
						<td>Parameter</td>
						<td>属性可应用于方法定义中的一个参数上</td>
					</tr>
					<tr>
						<td>Property</td>
						<td>属性可以应用于一个属性</td>
					</tr>
					<tr>
						<td>ReturnValue</td>
						<td>属性与函数的返回值相关</td>
					</tr>
					<tr>
						<td>Struct</td>
						<td>属性在结构上有效</td>
					</tr>
				</tbody>
			</table>
			② AllowMultiple: 定义用户是否能给元素添加一个或多个相同的属性.<br>
			③ Inherited: 设置属性义是否为可继承的.
		</div>	
		<pre class="prettyprint linenums">
<code>
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
public class TestCaseAttribute : Attribute
{
    public TestCaseAttribute(string testCase)
    {
        _testCase = testCase;
    }
 
    public void Test()
    {
        // Create an instance of the class under test
        // The test case object created is assumed to
        // test the object in its' constructor
        object o = Activator.CreateInstance(TestCase);
    }

    public Type TestCase
    {
        get
        {
            if (null == _testType) {
                _testType = Type.GetType(_testCase);
            }
            return _testType;
        }
    }
 
    private string  _testCase;
    private Type    _testType = null ;
}
</code>
		</pre>
    </div>

	<div class="title">属性的使用</div>
    <div class="content closed">
		<div class="list list-number">
			<div class="title">属性值</div>
			<div class="content open">
				<p>一切编译时可以确定的值, 包括, 常量, Static成员...</p>
			</div>

			<div class="title">属性作用域</div>
			<div class="content open">
				<p>
					设置属性的作用域, 即指定属性关联到什么成员上. 如果要定义属性的作用域, 可选择下述值:<br>
					1) assembly - 属性应用到程序集上<br>
					2) field - 属性应用到枚举或类的字段上<br>
					3) event - 属性应用到事件上<br>
					4) method - 属性应用到它前面的方法中<br>
					5) module - 属性存储在模块中<br>
					6) param - 属性应用到参数上<br>
					7) property - 属性存储在属性上<br>
					8) return - 属性应用到函数的返回值上<br>
					9) type - 属性应用到类, 接口或结构上
				</p>
				<p>
					上述的许多值都不常用, 因为作用域不是很明确. 但对于assemlby, module和return这几个值来说, 就必须使用作用域标志. 如果属性的定义区域有一些模糊, 编译器就会选择被赋给属性的对象. 当标记属性的返回值时, 这是最常见的, 如下所示:
				</p>
				<pre class="prettyprint linenums">
<code>
[SomeAttribute]
public string DoSomething();
</code>
				</pre>	
				<p>编译器猜测属性应用到方法上, 而不是返回值上. 以下述方式定义作用域, 才能获得期望的结果:</p>	
				<pre class="prettyprint linenums">
<code>
[return:SomeAttribute]
public string DoSomething();
</code>
				</pre>
			</div>

			<div class="title">自定义属性+使用范例</div>
			<div class="content closed">
				<a href="__ROOT__/static/files/cs/DataBaseAttributes.zip">代码范例</a>
			</div>
		</div>
    </div>
</div>

{include file="template/footer" /}