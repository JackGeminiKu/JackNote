{include file="template/header" title="C# XML编程" /}

<div class="list list-number">
	<!--XML DOM XML-->
    <div class="title">XML基本概念</div>
    <div class="content open">
		<div class="list list-number">

			<!--XML各种节点-->
			<div class="title">XML各种节点</div>
			<div class="content closed">
				<div class="list list-number">
					<!--XML文档-->
					<div class="title">Xml Document</div>
					<div class="content closed">
						<p>XML数据是分层组织的, 有点类似于Windows Explorer中的文件夹和文件. 每一个文档必须有且仅有一个根元素, 其中包含所有的元素和文本数据. 但是可以在顶级包括其他XML节点 --- 通常是XML声明. 所以下面的XML文档是合法的.</p>
						<pre class="prettyprint linenums">
<code>
&lt;?xml version = "1.0" ?>
&lt;books>
  &lt;book>Tristram Shandy&lt;/book>
  &lt;book>Moby Dick&lt;/book>
  &lt;book>Ulysses&lt;/book>
&lt;/books>
</code>
						</pre>
						<p>为了有一个格式良好的XML, 对文档的要求如下:<br>
							1) 有且仅有一个根元素<br>
							2) 每一个元素都有闭标记(前面提到的简短语法除外)<br>
							3) 没有重叠元素 --- 所有的子元素必须完全嵌套在父元素内<br>
							4) 所有的属性必须放在引号内 
						</p>
					</div>

					<!--XML声明-->
					<div class="title">Xml Declaration</div>
					<div class="content closed">
						<p>XML声明, 如果包括了它, 它就必须是文档的第一个节点. XML声明形式为:</p>
						<pre class="prettyprint linenums">
<code>
&lt;?xml version="1.0" encoding="utf-8" standalone="yes"?>
</code>
						</pre>
						<p>
							version属性: 当前, 其唯一可能的值是"1.0", 该属性不能省略.<br>
							encoding属性: 其值表示用于读取文档的字符集. 该属性可以省略.<br>
							standalone属性: 表示该文件是否呼叫了其它外部的文件. 若值是"yes"表示没有呼叫外部文件; 若值是"no"则表示有呼叫外部文件. 默认值是yes".  该属性可以省略. 这里所指的外部文件其实就是查检XML是不是有效的约束文件, 即DTD或者Schema. 
						</p>
					</div>

					<!--XML元素-->
					<div class="title">Xml Element</div>
					<div class="content closed">
						<p>XML元素包含一个开标记(比如&lt;元素名>), 元素中的数据, 以及闭标记(如&lt;/元素名>). 例如定义一个存储书名的元素: </p>
						<pre class="prettyprint linenums">
<code>
&lt;book>Tristram Shandy&lt;/book>
</code>
						</pre>
						<p>
							XML没有任何预定义元素 --- 而是由我们选择元素的名称, 因此可以拥有的元素个数没有限制. <br>
							而且元素名称区分大小写, 因此&lt;book>和&lt;Book>是不同的元素.
						</p>

						<p class="text-strong">空元素</p>
						<p>空元素是没有内嵌的数据或文本的元素. 例如: </p>
						<pre class="prettyprint linenums">
<code>
&lt;book>&lt;/book>	&lt;!-- 空元素 -->
&lt;book/>	&lt;!-- 简短语法: 没有闭元素! -->
</code>
						</pre>

						<p class="text-strong">嵌套&重叠</p>
						<p>元素也可以包含其他元素, 因此可以修改此&lt;book>元素, 添加两个子元素, 使之包括作者和标题, 例如:</p>
						<pre class="prettyprint linenums">
<code>
&lt;book>
    &lt;title>Tristram Shandy&lt;/title>
    &lt;auto>Lawrence Sterne&lt;/author>
&lt;/book>
</code>
						</pre>
						<p>但是元素不允许重叠, 因此在父元素的闭标记之前必须关闭所有的子元素. </p>
					</div>

					<!--XML属性-->
					<div class="title">Xml Attribute</div>
					<div class="content closed">
						<p>与在元素体内存储数据一样, 也可以在属性内存储数据, 属性添加到元素的开标记内. 属性的形式为: name = "value". 其中属性值必须包含在单引号或双引号内. 例如:</p>
						<pre class="prettyprint linenums">
<code>
&lt;book title = "Tristram Shandy">&lt;/book>
</code>
						</pre>

						<p class="text-strong">为什么在XML中需要两种方式存储数据? 下面二者的区别是什么?</p>
						<pre class="prettyprint linenums">
<code>
&lt;book>
    &lt;title>Tristram Shandy&lt;/title>
&lt;/book>
</code>
						</pre>	
						<pre class="prettyprint linenums">
<code>
&lt;book title = "Tristram Shndy">&lt;/book>
</code>
						</pre>
						<p>
							最坦白的答案是: 二者没有太大的区别. 使用其中任何一个都没有什么优势可言.<br>
							如果以后需要对数据添加更多的信息, 最好选择使用元素 --- 因为总是可以给元素添加子元素或属性, 但是对属性就不能进行这样的操作. 值得争论的事, 元素是否更易于读取, 更简洁(这只能根据个人不同的爱好来决定).<br>
							另一方面, 如果未经压缩就出现在网络上传输文档, 则属性会占用更少的带宽(即使压缩了, 区别也不是很大), 更便于保存对文档的每一位用户而言无关紧要的信息. 
						</p>
					</div>

					<!--XMLText-->
					<div class="title">XML Text</div>
					<div class="content closed">
						<p>表示元素或属性的文本内容</p>
					</div>

					<!--Xml注释-->
					<div class="title">Xml Comment</div>
					<div class="content closed">
						<pre class="prettyprint linenums">
<code>
&lt;!--这里是XML注释-->
</code>
						</pre>
					</div>

					<!--CDATA-->
					<div class="title">XML CDATA</div>
					<div class="content closed">
						<div class="list list-number">
							<p>所有 XML 文档中的文本均会被解析器解析。只有 CDATA 区段（CDATA section）中的文本会被解析器忽略。</p>
							<div class="title">实体引用</div>
							<div class="content open">
								<p>假如您在 XML 文档中放置了一个类似 "<" 字符，那么这个文档会产生一个错误，这是因为解析器会把它解释为新元素的开始。因此你不能这样写：</p>
								<pre class="prettyprint linenums">
<code>
&lt;message>if salary &lt; 1000 then&lt;/message>
</code>
								</pre>	
								<p>为了避免此类错误，需要把字符 "<" 替换为实体引用，就像这样：</p>
								<pre class="prettyprint linenums">
<code>
&lt;message>if salary &#38;lt; 1000 then&lt;/message>
</code>
								</pre>		
								<p>在XML中有5个预定义的实体引用:</p>
								<table class="table table-bordered table-sm w-25">
									<tbody>
										<tr>
											<td>&lt;</td>
											<td>&#38;lt;</td>
										</tr>
										<tr>
											<td>&gt;</td>
											<td>&#38gt;</td>
										</tr>
										<tr>
											<td>&amp;</td>
											<td>&#38;amp;</td>
										</tr>
										<tr>
											<td>单引号: &apos;</td>
											<td>&#38;apos;</td>
										</tr>
										<tr>
											<td>双引号: &quot;</td>
											<td>&#38quot;</td>
										</tr>
									</tbody>
								</table>
								<p class="text-danger">注意: 只有"&lt;"字符和"&amp;"字符对于XML来说是严格禁止使用的. 剩下的都是合法的, 但是为了减少出错, 使用实体是一个好习惯.</p>
							</div>

							<div class="title">CDATA部件</div>
							<div class="content open">
								<p>
									一个CDATA部件以"&lt;![CDATA["标记开始, 以"]]>标记结束:<br>
									在CDATA内部的所有内容都会被解析器忽略. 如果文本包含了很多的"<"符号和"&"字符 --- 就像程序代码一样, 那么最好把它们都放到CDATA部件中.<br>
									注意: CDATA不支持嵌套.
								</p>
								<pre class="prettyprint linenums">
<code>
&lt;script>&lt;![CDATA[
function matchwo(a,b)
{
  if (a &lt; b && a &lt; 0) then {
    return 1
  } else {
    return 0
  }
}
]]>&lt;/script>
</code>
								</pre>
							</div>
						</div>
					</div>
				</div>	
			</div>

			<!--XML命令空间-->
			<div class="title">XML命名空间</div>
			<div class="content closed">
				<p>XML命名空间非常复杂, 因此在此不详细介绍它, 但其基本语法非常简单. 使用前缀, 后跟冒号, 就可以将具体的元素或属性关联到特定的命名空间. 例如, &lt;wrox:book>表示wrox命名空间中的&lt;book>元素. </p>
				<p>
					但是如何知道命名空间wrox所表示的内容呢? 为了使此方法有效, 必须保证每个命名空间都是唯一的. 
					最简单的办法是将前缀映射到某些独特的事务上. 如下所示: 在XML文档的某个位置, 需要将命名空间前缀关联到Uniform Resource Identifier(唯一资源标识符, URI)上. URI有几个种类, 最常见的类型是Web地址, 比如http://www.wrox.com.
				</p>

				<p class="text-strong">为了用具体的命名空间标识前缀, 可以在元素内使用xmlns:prefix属性, 将其属性设置为标识命名空间的唯一URI. 然后前缀就可以用于该元素的任何位置, 包括任何内嵌的子元素. 例如:</p>
				<pre class="prettyprint linenums">
<code>
&lt;?xml version = "1.0"?>
&lt;books>
  &lt;book xmlns:wrox = "http://www.wrox.com">
    &lt;wrox:title>Beginning C#&lt;/wrox:title>
    &lt;wrox:author>Karli Watson&lt;/wrox:author>
  &lt;/book>
&lt;/books>
</code>
				</pre>
				<p>在此&lt;title>和&lt;author>元素使用wrox:前缀, 因为它们位于&lt;book>元素内, 其中定义了该前缀. 但是如果试图将此前缀添加到&lt;books>元素上, XML就是非法的, 因为并没有为此元素定义前缀.</p>

				<p class="text-strong">也可以使用xmlns属性为元素定义默认的命名空间:</p>
				<pre class="prettyprint linenums">
<code>
&lt;?xml version = "1.0"?>
&lt;books>
  &lt;book xmlns = "http://www.wrox.com">  &lt;!-- 定义默认命名空间 -->
    &lt;title>Beginning C#&lt;/title>
    &lt;author>Karli Watson&lt;/author>
    &lt;html:img src = "begcsharp.gif" xmlns:html = "http://www.w3.org/1999/xhtml"? />
  &lt;/book>
&lt;/books>
</code>
				</pre>
			</div>

			<div class="title">XPath表达式</div>
			<div class="content closed">
				<table class="table table-bordered table-sm w-75">
					<tbody>
						<tr>
							<th>符号</th>
							<th>说明</th>
							<th>实例</th>
						</tr>
						<tr>
							<td>/</td>
							<td>从根节点开始选择</td>
							<td>/pets: 选择根节点下的pets</td>
						</tr>
						<tr>
							<td></td>
							<td>表示节点和子节点之间的间隔符</td>
							<td>/pets/dog: 选择根节点pets下的dogs节点</td>
						</tr>
						<tr>
							<td>//xx</td>
							<td>表示从这个Xml文档中查找, 而不考虑当前节点的位置</td>
							<td>//price: 选择文档中所有的price节点</td>
						</tr>
						<tr>
							<td>.</td>
							<td>选择当前节点</td>
							<td>/pets/.: 选择pets节点</td>
						</tr>
						<tr>
							<td>..</td>
							<td>选择父节点</td>
							<td>/pets/dog[0]/..: 选择pets节点, 也就是第一个dog节点的父节点</td>
						</tr>
						<tr>
							<td>@xx</td>
							<td>选择属性</td>
							<td>//dog/@color: 选择所有dog节点的color属性集合</td>
						</tr>
						<tr>
							<td>[...]</td>
							<td>指定条件</td>
							<td>
								//dog[@color='white']: 选择所有color为white的dog节点 <br>
								//dog[/price<100]: 选择所有price子节点值小于100的dog节点
							</td>
						</tr>
						<tr>
							<td></td>
							<td>指定索引(索引从1开始)</td>
							<td>
								//dog[1]: 选择第一个dog节点 <br>
								//dog[last()]: 选择最后一个节点
							</td>
						</tr>
						<tr>
							<td>*</td>
							<td>表示任何名字的节点或属性</td>
							<td>//dog/@*: 选择dog节点的所有属性</td>
						</tr>
						<tr>
							<td>|</td>
							<td>合并节点</td>
							<td>//dog[@color='white'] | //cat[@color='white']: 选择color属性为white的dog节点和color属性为white的cat节点</td>
						</tr>
					</tbody>
				</table>	
			</div>	
		</div> 
	</div>

	<div class="title">System.Xml中的常用操作</div>
	<div class="content open">
		<div class="list list-number">
			<div class="title">读XML文档</div>
			<div class="content closed">
				<table class="table table-bordered table-sm w-50">
					<tbody>
						<tr>
							<td>XmlDocument</td>
							<td>扩展XmlNode, W3C DOM的实现, 给出XML文档在内存中的树形表示, 可以浏览和编辑它们.</td>
						</tr>
						<tr>
							<td>
								XmlReader<br>
								XmlTextReader
							</td>
							<td>
								抽象的读取器, 提供快速, 没有缓存的XML数据, 但是只能向前.<br>
								扩展XmlReader, 提供访问XML数据的快速只向前流.
							</td>
						</tr>
					</tbody>
				</table>
				<p>
					XmlReader是基于数据流的, 占用极少的内存, 是只读方式的, 所以速度极快. 只能采用遍历的模式查找数据节点.<br>
					XmlDocument是基于树形结构的模型, 数据保存于内存中, 可以查找内存中数据的任何方面. 占用内存大, 处理方便, 可读可写, 几乎相当于一次把Xml读入内存.<br>
					所以: 如果数据量极大,用XmlReader合适, 如果处理复杂频繁且文件不大, XmlDocument合适. 
				</p>

				<div class="list list-number">
					<div class="title">使用XmlReader</div>
					<div class="content closed">
						<p class="text-strong">移动到下一个节点</p>
						<p>
							xmlReader.Read() <br>
							When an XmlReader is first created and initialized, there is no information available. You must call Read to read the first node. <br>
							Read()方法不会移动到Attribute Node, Attribute Node可以看作是Element Node的子Node. 如果想要移动到Attribute Node, 需要先移动到Element Node, 然后再使用MoveToAttribute()方法, 最后使用MoveToElement()方法在移回来!
						</p>

						<p class="text-strong">范例</p>
						<pre class="prettyprint linenums">
<code>
static void Main(string[] args)
{
    // 声明StringReader传入Xml文本，作为.Create的参数 ?
    using (StringReader strRdr = new StringReader(@"&lt;?xml version=""1.0"" encoding=""utf-8"" ?>
                                                    &lt;root>
                                                        &lt;cat color=""white"">I'm a Cat&lt;/cat>
                                                        &lt;dog color=""yellow""/>
                                                    &lt;/root>")) {
        using (XmlReader xmlReader = XmlReader.Create(strRdr)) {    // 通过.Create静态方法创建XmlReader实例
            while (xmlReader.Read()) {  // 循环方法直到文档结束
                Console.WriteLine("NodeType = " + xmlReader.NodeType);
                Console.WriteLine("Name = " + xmlReader.Name);
                Console.WriteLine("Local Name = " + xmlReader.LocalName);
                Console.WriteLine("Value = " + xmlReader.Value);

                if (xmlReader.NodeType == XmlNodeType.Element) {
                    if (xmlReader.AttributeCount > 0) {
                        Console.WriteLine("Attribute 0 = " + xmlReader.GetAttribute(0)); // 也可以指定key
                    }
                    // ... 
                } else if (xmlReader.NodeType == XmlNodeType.EndElement) {
                    // ...
                }
            }
        }
    }
}
</code>
						</pre>
					</div>

					<div class="title">使用XmlDocument</div>
					<div class="content closed">
						<pre class="prettyprint linenums">
<code>
XmlDocument document = new XmlDocument();
document.Load(@"D:\books.xml");
...
</code>
						</pre>
					</div>
				</div>
			</div>

			<div class="title">写XML文档</div>
			<div class="content closed">
				<div class="list list-number">
					<table class="table table-bordered table-sm w-50">
						<tbody>
							<tr>
								<td>XmlDocument</td>
								<td>扩展XmlNode, W3C DOM的实现, 给出XML文档在内存中的树形表示, 可以浏览和编辑它们.</td>
							</tr>
							<tr>
								<td>
									XmlWriter<br>
									XmlTextWriter
								</td>
								<td>
									抽象的写入器类, 以流或文件的格式提供快速, 没有缓存的XML数据.<br>
									扩展XmlWriter, 快速生成只向前的XML流.
								</td>
							</tr>
						</tbody>
					</table>

					<div class="list list-number">
						<div class="title">使用XmlWriter</div>
						<div class="content closed">
							<p class="text-strong">生成XmlWriter对象</p>
							<pre class="prettyprint linenums">
<code>
XmlWriterSettings settings = new XmlWriterSettings()
Settings.Indent = true;                          // 要求缩进
settings.Encoding = Encoding.UTF8;               // 如果不设置Encoding, 默认将输出UTF8
settings.NewLineChars = Environment.NewLine;     // 设置换行符
　
XmlWriter xmlWriter = XmlWriter.Create("test.xml",settings);
</code>
							</pre>

							<p class="text-strong">生成Xml文档说明</p>
							<p>
								WriteStartDocument()方法可以接受一个bool参数（表示standalone，是否为独立文档）或者不指定参数standalone保持默认值. <br>
								注意: 在使用WriteStartDocument()方法后, 最好调用xmlWrite.WriteEndDocument()方法, 来关闭所有可能未关闭标签.
							</p>

							<p class="text-strong">生成Xml元素</p>
							<pre class="prettyprint linenums">
<code>
xmlWriter.WriteStartElement("cat");                   // 写元素
　
xmlWriter.WriteAttributeString("color", "white");    // 给元素添加属性
xmlWriter.WriteString("I'm a cat");                  // 给元素内部添加文本
xmlWriter.WriteCData("<strong>dog is dog</strong>"); // 给元素内部添加CDATA
　
xmlWriter.WriteEndElement();                         // 关闭元素
</code>
							</pre>
							<p>另外, 可以通过WriteElementString(string,string)方法写xml元素, 并且同时写下节点值，例如: xmlWriter.WriteElementString("pig", "pig is great");</p>

							<p class="text-strong">生成Xml注释</p>
							<pre class="prettyprint linenums">
<code>
xmlWriter.WriteComment("This is comment.");
</code>
							</pre>
						</div>

						<div class="title">使用XmlDocument</div>
						<div class="content closed">
							<pre class="prettyprint linenums">
<code>
XmlDocument document = new XmlDocument();
document.Load(@"D:\books.xml");
...
document.Save(@"D:\books.xml");
</code>
							</pre>
						</div>
					</div>
				</div>
			</div>

			<div class="title">创建&插入新节点 - XmlDocument & XmlNode</div>
			<div class="content closed">
				<p>XmlNode, XmlElement, XmlAttribute, XmlText, 以及XmlComment这几个类都只有一个受保护的构造函数, 所以不能直接使用new创建它们的实例. 但是可以使用XmlDocument类的方法来创建它们的实例!</p>
				<p>在创建节点后, 节点并没有插入到文档中, 需要使用派生于XmlNode类(包括XmlDocument和XmlElement)的方法: AppendChild(), InsertAfter() & InsertBefore()将节点插入.</p>
			</div>

			<div class="title">删除节点 - XmlNode</div>
			<div class="content closed">
				<p>派生于XmlNode的所有类型(包括XmlDocument和XmlElement)都包含从文档中删除节点的方法: RemoveAll() & RemoveChild()</p>
			</div>

			<div class="title">选择节点 - XmlNode</div>
			<div class="content closed">
				<p>详见XPath表达式部分!</p>
			</div>

			<div class="title">验证XML文档</div>
			<div class="content closed">
				<p>
					XML支持两种方法, 定义在文档中可以放置哪些元素和属性, 以及其放置顺序 --- 文档类型定义(Document Type Definitions, DTD)和模式. DTD使用从XML的父文档继承的非XML语法, 并逐渐被模式所代替. DTD不允许规定元素和属性的数据类型, 因此不太灵活, 在.NET Framework的环境中使用得不多. 另一方面, 模式使用得非常多 --- 它们允许规定数据类型, 使用XML兼容的语法编写的. 但是, 模式非常复杂, 有不同的格式定义它们 --- 即使在.NET中也是如此!
				</p>
				<p>.NET支持的模式又具有两种不同的格式 --- XML Schema Definition语言(XSD)和XML Data Reduced模式(XDR). 模式可以包含在XML文档内, 也可以放在单独的文件中.</p>
				<p class="text-strong">XSD模式</p>
				<p>为了将XML文档与另一个文件中的XSD模式关联, 需要在根元素中添加schemalocation元素:</p>	
				<div class="container-fluid">
					<div class="row">
						<div class="col-6">
							<pre class="prettyprint linenums">
<code>
&lt;!--使用XSD模式的XML文档-->
&lt;?xml version = "1.0" ?>
&lt;books schemalocation = "file://C:\BegVCSharp\XML\books.xsd">&lt;!--XSD文件路径-->
  &lt;book>
    &lt;title>Beginning Visual C#&lt;/title>
    &lt;author>Karli Waston&lt;/author>
    &lt;code>7582&lt;/code>
  &lt;/book>
  &lt;book>
    &lt;title>Profesional C# 2nd Edition&lt;/title>
    &lt;author>Simon Robinson&lt;/author>
    &lt;code>7043&lt;/code>
  &lt;/book>
&lt;/books>



</code>
							</pre>
						</div>
						<div class="col-6">
							<pre class="prettyprint linenums">
<code>
&lt;!--XSD模式-->
&lt;schema xmlns = "http://www.w3.org/2001/XMLSchema">
  &lt;element name = "books">
    &lt;choice maxOccurs = "unbounded">
      &lt;element name = "book">
        &lt;complexType>
          &lt;sequence>
            &lt;element name = "title" />
            &lt;element name = "author" />
            &lt;element name = "code" />
          &lt;/sequence>
        &lt;/complexType>
      &lt;/element>
    &lt;/choice>
    &lt;attribute name = "shcemalocation" />
  &lt;/element>
&lt;/schema>
</code>
							</pre>	
						</div>
					</div>
				</div>
				<p>在此首先要注意, 默认命名空间设置为XSD命名空间. 这就告诉分析程序, 文档中的所有元素属于模式. 如果不规定此命名空间, 分析程序就认为元素仅仅是普通的XML元素, 认识不到需要使用它们进行验证.</p>
				<p>
					1) 完整的模式包含在&lt;schema>元素内(使用小写"s"). <br>
					2) 文档中的每个元素都必须由&lt;element>元素来表示. 此元素具有指示元素名称的name属性. <br>
					3) 如果元素包含嵌套的子元素, 就必须在&lt;complexType>元素内为这些子元素包含&lt;element>标记. 在&lt;complexType>元素中, 规定子元素的操作方式. 例如, 使用&lt;choice>元素规定对子元素进行选择操作, 或使用&lt;sequence>规定子元素必须以它们在模式中列举的顺序出现. <br>
					4) 如果一个元素可能出现多次(如&lt;book>元素), 就需要在其父元素内包括maxOccurs属性. 将其设置为unbounded, 表示元素可以出现需要的次数. <br>
					5) 最后, 属性必须由&lt;attribute>元素表示, 包括schemalocation属性, 它告诉分析程序模式所在的位置. 它放在子元素列表的结尾处.
				</p>

				<p class="text-strong">XDR模式 (Microsoft专用)</p>
				<p>为了将外部的XDR模式应用到XML文档上, 可以为带有值"x-schema:&lt;schema_filename>"的文档规定一个命名空间:</p>	
				<div class="container-fluid">
					<div class="row">
						<div class="col-6">
							<pre class="prettyprint linenums">
<code>
&lt;!--X使用XDR模式的XML文档-->
&lt;?xml version = "1.0" ?>
&lt;books xmlns = "x-schema:books.xdr">
    &lt;book>
        &lt;title>Beginning Visual C#&lt;/title>
        &lt;author>Karli Waston&lt;/author>
        &lt;code>7582&lt;/code>
    &lt;/book>
    &lt;book>
        &lt;title>Profesional C# 2nd Edition&lt;/title>
        &lt;author>Simon Robinson&lt;/author>
        &lt;code>7043&lt;/code>     
    &lt;/book>
&lt;/books>
</code>
							</pre>
						</div>
						<div class="col-6">
							<pre class="prettyprint linenums">
<code>
&lt;!--XDR模式-->
&lt;Schema xmlns = "urn:schemas-microsoft-com:xml-data">
  &lt;ElementType name = "title" content = "textOnly">
  &lt;ElementType name = "author" content = "textOnly">
  &lt;ElementType name = "code" conent = "textOnely">
  &lt;ElementType name = "book" content = "textOnly">
    &lt;group order = "seq">
      &lt;element type = "title" />
      &lt;element type = "author" />
      &lt;element type = "code" />
    &lt;/group>
  &lt;/ElementType>
  &lt;ElementType name = "books" content = "textOnly">
    &lt;Element type = "book" />
  &lt;/ElementType>     
&lt;/Schema>
</code>
							</pre>
						</div>
					</div>
				</div>
				<p>再次设置默认的命名空间, 告诉分析程序, 文档中的所有元素都属于模式定义:这次的命名空间是urn:schemas-microsoft-com:xml-data.注意, 它与XSD模式不同, 此模式是专用格式, 所以不可用于非Microsoft产品. 事实上, 当与SQL Server和Microsoft的数据库服务器一起使用时, XDR模式非常有用, 因为它具有对XDR的内置支持.</p>
				<p>这次的根元素是带有大写字母"S"的&lt;Schema>. 这个根元素再次包含了完整的模式定义. 但是之后, 就有了较大的区别 --- 文档中的元素按反序出现! 其原因是, 文档中的每一个元素由模式中的&lt;ElementType>元素表示, 它为每个子元素包含了一个&lt;element>元素(注意此处是小写"e"). 在&lt;element>标记内, type属性设置为指向&lt;ElementType>元素 --- 这必须是一家已经定义好的. 如果希望限制元素出现的方式, 就可以在&lt;ElementType>元素内使用&lt;group>元素, 并设置order属性. 在此, 将其设置为"seq", 规定元素按在模式中相同的顺序出现 --- 与在XSD模式中的&lt;sequence>标记相同.</p>
			</div>
		</div>
	</div>

	<div class="title">System.Xml.Linq中的常用操作</div>
    <div class="content closed">
		<pre class="prettyprint linenums">
<code>
using System.Xml.XPath;
xelement.XPathSelectElement(xpath);
</code>
		</pre>
    </div>
</div>

{include file="template/footer" /}