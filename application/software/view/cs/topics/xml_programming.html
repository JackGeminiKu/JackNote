{include file="template/header" title="C# XML编程" /}

<div class="list list-number">
	<!--XML DOM XML-->
    <div class="title">XML文档介绍</div>
    <div class="content open">
		<div class="list list-number">
			<!--XML文档-->
			<div class="title">XML Document</div>
			<div class="content closed">
				<div class="list list-none">
					<div class="title">XML文档结构</div>
					<div class="content open">
						<p>XML数据是分层组织的, 有点类似于Windows Explorer中的文件夹和文件. 每一个文档必须有且仅有一个根元素, 其中包含所有的元素和文本数据. 但是可以在顶级包括其他XML节点 --- 通常是XML声明. 所以下面的XML文档是合法的.</p>
						<pre class="prettyprint linenums">
<code>
&lt;?xml version = "1.0" ?>
&lt;books>
  &lt;book>Tristram Shandy&lt;/book>
  &lt;book>Moby Dick&lt;/book>
  &lt;book>Ulysses&lt;/book>
&lt;/books>
</code>
						</pre>
						<p>为了有一个格式良好的XML, 对文档的要求如下:<br>
							1) 有且仅有一个根元素<br>
							2) 每一个元素都有闭标记(前面提到的简短语法除外)<br>
							3) 没有重叠元素 --- 所有的子元素必须完全嵌套在父元素内<br>
							4) 所有的属性必须放在引号内 
						</p>
					</div>


				</div>
			</div>

			<!--XML声明-->
			<div class="title">Xml Declaration</div>
			<div class="content closed">
				<p>XML声明, 如果包括了它, 它就必须是文档的第一个节点. XML声明形式为:</p>
				<pre class="prettyprint linenums">
<code>
&lt;?xml version="1.0" encoding="utf-8" standalone="yes"?>
</code>
				</pre>
				<p>
					version属性: 当前, 其唯一可能的值是"1.0", 该属性不能省略.<br>
					encoding属性: 其值表示用于读取文档的字符集. 该属性可以省略.<br>
					standalone属性: 表示该文件是否呼叫了其它外部的文件. 若值是"yes"表示没有呼叫外部文件; 若值是"no"则表示有呼叫外部文件. 默认值是yes".  该属性可以省略. 这里所指的外部文件其实就是查检XML是不是有效的约束文件, 即DTD或者Schema. 
				</p>
			</div>

			<!--XML元素-->
			<div class="title">Xml Element</div>
			<div class="content closed">
				<p>XML元素包含一个开标记(比如&lt;元素名>), 元素中的数据, 以及闭标记(如&lt;/元素名>). 例如定义一个存储书名的元素: </p>
				<pre class="prettyprint linenums">
<code>
&lt;book>Tristram Shandy&lt;/book>
</code>
				</pre>
				<p>
					XML没有任何预定义元素 --- 而是由我们选择元素的名称, 因此可以拥有的元素个数没有限制. <br>
					而且元素名称区分大小写, 因此&lt;book>和&lt;Book>是不同的元素.
				</p>

				<p class="text-strong">空元素</p>
				<p>空元素是没有内嵌的数据或文本的元素. 例如: </p>
				<pre class="prettyprint linenums">
<code>
&lt;book>&lt;/book>	&lt;!-- 空元素 -->
&lt;book/>	&lt;!-- 简短语法: 没有闭元素! -->
</code>
				</pre>

				<p class="text-strong">嵌套&重叠</p>
				<p>元素也可以包含其他元素, 因此可以修改此&lt;book>元素, 添加两个子元素, 使之包括作者和标题, 例如:</p>
				<pre class="prettyprint linenums">
<code>
&lt;book>
    &lt;title>Tristram Shandy&lt;/title>
    &lt;auto>Lawrence Sterne&lt;/author>
&lt;/book>
</code>
				</pre>
				<p>但是元素不允许重叠, 因此在父元素的闭标记之前必须关闭所有的子元素. </p>
			</div>

			<!--XML属性-->
			<div class="title">Xml Attribute</div>
			<div class="content closed">
				<p>与在元素体内存储数据一样, 也可以在属性内存储数据, 属性添加到元素的开标记内. 属性的形式为: name = "value". 其中属性值必须包含在单引号或双引号内. 例如:</p>
				<pre class="prettyprint linenums">
<code>
&lt;book title = "Tristram Shandy">&lt;/book>
</code>
				</pre>

				<p class="text-strong">为什么在XML中需要两种方式存储数据? 下面二者的区别是什么?</p>
				<pre class="prettyprint linenums">
<code>
&lt;book>
    &lt;title>Tristram Shandy&lt;/title>
&lt;/book>
</code>
				</pre>	
				<pre class="prettyprint linenums">
<code>
&lt;book title = "Tristram Shndy">&lt;/book>
</code>
				</pre>
				<p>
					最坦白的答案是: 二者没有太大的区别. 使用其中任何一个都没有什么优势可言.<br>
					如果以后需要对数据添加更多的信息, 最好选择使用元素 --- 因为总是可以给元素添加子元素或属性, 但是对属性就不能进行这样的操作. 值得争论的事, 元素是否更易于读取, 更简洁(这只能根据个人不同的爱好来决定).<br>
					另一方面, 如果未经压缩就出现在网络上传输文档, 则属性会占用更少的带宽(即使压缩了, 区别也不是很大), 更便于保存对文档的每一位用户而言无关紧要的信息. 
				</p>
			</div>

			<!--XMLText-->
			<div class="title">XML Text</div>
			<div class="content closed">
				<p>表示元素或属性的文本内容</p>
			</div>

			<!--Xml注释-->
			<div class="title">Xml Comment</div>
			<div class="content closed">
				<pre class="prettyprint linenums">
<code>
&lt;!--这里是XML注释-->
</code>
				</pre>
			</div>

			<!--CDATA-->
			<div class="title">XML CDATA</div>
			<div class="content closed">
				<div class="list list-number">
					<p>所有 XML 文档中的文本均会被解析器解析。只有 CDATA 区段（CDATA section）中的文本会被解析器忽略。</p>
					<div class="title">实体引用</div>
					<div class="content open">
						<p>假如您在 XML 文档中放置了一个类似 "<" 字符，那么这个文档会产生一个错误，这是因为解析器会把它解释为新元素的开始。因此你不能这样写：</p>
						<pre class="prettyprint linenums">
<code>
&lt;message>if salary &lt; 1000 then&lt;/message>
</code>
						</pre>	
						<p>为了避免此类错误，需要把字符 "<" 替换为实体引用，就像这样：</p>
						<pre class="prettyprint linenums">
<code>
&lt;message>if salary &#38;lt; 1000 then&lt;/message>
</code>
						</pre>		
						<p>在XML中有5个预定义的实体引用:</p>
						<table class="table table-bordered table-sm w-25">
							<tbody>
								<tr>
									<td>&lt;</td>
									<td>&#38;lt;</td>
								</tr>
								<tr>
									<td>&gt;</td>
									<td>&#38gt;</td>
								</tr>
								<tr>
									<td>&amp;</td>
									<td>&#38;amp;</td>
								</tr>
								<tr>
									<td>单引号: &apos;</td>
									<td>&#38;apos;</td>
								</tr>
								<tr>
									<td>双引号: &quot;</td>
									<td>&#38quot;</td>
								</tr>
							</tbody>
						</table>
						<p class="text-danger">注意: 只有"&lt;"字符和"&amp;"字符对于XML来说是严格禁止使用的. 剩下的都是合法的, 但是为了减少出错, 使用实体是一个好习惯.</p>
					</div>

					<div class="title">CDATA部件</div>
					<div class="content open">
						<p>
							一个CDATA部件以"&lt;![CDATA["标记开始, 以"]]>标记结束:<br>
							在CDATA内部的所有内容都会被解析器忽略. 如果文本包含了很多的"<"符号和"&"字符 --- 就像程序代码一样, 那么最好把它们都放到CDATA部件中.<br>
							注意: CDATA不支持嵌套.
						</p>
						<pre class="prettyprint linenums">
<code>
&lt;script>&lt;![CDATA[
function matchwo(a,b)
{
  if (a &lt; b && a &lt; 0) then {
    return 1
  } else {
    return 0
  }
}
]]>&lt;/script>
</code>
						</pre>
					</div>
				</div>

			</div>

			<!--XML命令空间-->
			<div class="title">XML命名空间</div>
			<div class="content closed">
				<p>XML命名空间非常复杂, 因此在此不详细介绍它, 但其基本语法非常简单. 使用前缀, 后跟冒号, 就可以将具体的元素或属性关联到特定的命名空间. 例如, &lt;wrox:book>表示wrox命名空间中的&lt;book>元素. </p>
				<p>
					但是如何知道命名空间wrox所表示的内容呢? 为了使此方法有效, 必须保证每个命名空间都是唯一的. 
					最简单的办法是将前缀映射到某些独特的事务上. 如下所示: 在XML文档的某个位置, 需要将命名空间前缀关联到Uniform Resource Identifier(唯一资源标识符, URI)上. URI有几个种类, 最常见的类型是Web地址, 比如http://www.wrox.com.
				</p>

				<p class="text-strong">为了用具体的命名空间标识前缀, 可以在元素内使用xmlns:prefix属性, 将其属性设置为标识命名空间的唯一URI. 然后前缀就可以用于该元素的任何位置, 包括任何内嵌的子元素. 例如:</p>
				<pre class="prettyprint linenums">
<code>
&lt;?xml version = "1.0"?>
&lt;books>
  &lt;book xmlns:wrox = "http://www.wrox.com">
    &lt;wrox:title>Beginning C#&lt;/wrox:title>
    &lt;wrox:author>Karli Watson&lt;/wrox:author>
  &lt;/book>
&lt;/books>
</code>
				</pre>
				<p>在此&lt;title>和&lt;author>元素使用wrox:前缀, 因为它们位于&lt;book>元素内, 其中定义了该前缀. 但是如果试图将此前缀添加到&lt;books>元素上, XML就是非法的, 因为并没有为此元素定义前缀.</p>

				<p class="text-strong">也可以使用xmlns属性为元素定义默认的命名空间:</p>
				<pre class="prettyprint linenums">
<code>
&lt;?xml version = "1.0"?>
&lt;books>
  &lt;book xmlns = "http://www.wrox.com">  &lt;!-- 定义默认命名空间 -->
    &lt;title>Beginning C#&lt;/title>
    &lt;author>Karli Watson&lt;/author>
    &lt;html:img src = "begcsharp.gif" xmlns:html = "http://www.w3.org/1999/xhtml"? />
  &lt;/book>
&lt;/books>
</code>
				</pre>
			</div>
		</div> 
	</div>

	<div class="title">XML常用操作</div>
	<div class="content open">
		<div class="list list-number">
			<div class="title">读XML文档</div>
			<div class="content open">
				<table class="table table-bordered table-sm w-50">
					<tbody>
						<tr>
							<td>XmlDocument</td>
							<td>扩展XmlNode, W3C DOM的实现, 给出XML文档在内存中的树形表示, 可以浏览和编辑它们.</td>
						</tr>
						<tr>
							<td>
								XmlReader<br>
								XmlTextReader
							</td>
							<td>
								抽象的读取器, 提供快速, 没有缓存的XML数据, 但是只能向前.<br>
								扩展XmlReader, 提供访问XML数据的快速只向前流.
							</td>
						</tr>
					</tbody>
				</table>
				<p>
					XmlReader是基于数据流的, 占用极少的内存, 是只读方式的, 所以速度极快. 只能采用遍历的模式查找数据节点.<br>
					XmlDocument是基于树形结构的模型, 数据保存于内存中, 可以查找内存中数据的任何方面. 占用内存大, 处理方便, 可读可写, 几乎相当于一次把Xml读入内存.<br>
					所以: 如果数据量极大,用XmlReader合适, 如果处理复杂频繁且文件不大, XmlDocument合适. 
				</p>
			</div>

			<div class="title">写XML文档</div>
			<div class="content open">
				<div class="list list-number">
					<table class="table table-bordered table-sm w-50">
						<tbody>
							<tr>
								<td>XmlDocument</td>
								<td>扩展XmlNode, W3C DOM的实现, 给出XML文档在内存中的树形表示, 可以浏览和编辑它们.</td>
							</tr>
							<tr>
								<td>
									XmlWriter<br>
									XmlTextWriter
								</td>
								<td>
									抽象的写入器类, 以流或文件的格式提供快速, 没有缓存的XML数据.<br>
									扩展XmlWriter, 快速生成只向前的XML流.
								</td>
							</tr>
						</tbody>
					</table>
				</div>
			</div>

			<div class="title">创建&插入新节点 - XmlDocument & XmlNode</div>
			<div class="content open">

			</div>

			<div class="title">删除节点 - XmlNode</div>
			<div class="content open">

			</div>

			<div class="title">选择节点 - XmlNode</div>
			<div class="content open">

			</div>

			<div class="title">在VS中创建XML文档</div>
			<div class="content open">

			</div>

			<div class="title">验证XML文档</div>
			<div class="content open">

			</div>
		</div>
	</div>

	<div class="title">XML & Linq</div>
    <div class="content open">

    </div>
</div>

{include file="template/footer" /}