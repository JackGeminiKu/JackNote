{include file="template/header" title="C# 数据库编程" /}
<div class="list list-number">
	<!--ADO.NET-->
    <div class="title">ADO.NET</div>
    <div class="content open">
		<div class="list list-number">
			<div class="title">数据提供者</div>
			<div class="content open">
				<div class="list list-number">
					<div class="title">概述</div>
					<div class="content open">
						<p>数据提供者对象用于每一种类型的数据源, 专用于提供者的对象完成数据源中实际的读取和写入工作.</p>
						<table class="table table-bordered table-sm w-50">
							<tbody>
								<tr>
									<th>1. Connection</th>
									<td>访问数据库之前, 必须先连接!</td>
								</tr>
								<tr>
									<th>2. Command</th>
									<td>可以使用此对象给数据源发出命令, 比如"select * from Customers"查询Customers表中的数据.</td>
								</tr>
								<tr>
									<th>3. CommandBuilder</th>
									<td>此对象用于构建SQL命令, 在基于单一表查询的对象中进行数据修改.</td>
								</tr>
								<tr>
									<th>4. DataReader</th>
									<td>可以从数据源中读取仅能向前和只读的数据流(比如找到的用户集合). 对于简单地读取数据来说, 此对象的性能最好. </td>
								</tr>
								<tr>
									<th>5. DataAdapter</th>
									<td>可以执行针对数据源的各种操作, 包括更新变动的数据, 填充DataSet对象以及其他操作.</td>
								</tr>
							</tbody>
						</table>
					</div>

					<div class="title">MS SQL Server数据提供者</div>
					<div class="content open">
						<div class="list list-number">
							<div class="title">SqlConnection</div>
							<div class="content closed">
								<pre class="prettyprint linenums">
<code>
// 对应SqlConnection对象
SqlConnection connection = new SqlConnection("Server=localhost;Database=pubs;User ID=sa;Password=vbdotnet"); // 方法1
SqlConnection connection = new SqlConnection(); // 方法2
connection.ConnectionString = "Server=localhost;Database=pubs;User ID=sa;Password=vbdotnet";

// 打开&关闭连接
connection.Open();
connection.Close();
</code>
								</pre>
							</div>

							<div class="title">SqlCommand</div>
							<div class="content closed">
								<div class="list list-number">
									<div class="title">定义Command</div>
									<div class="content open">
										<pre class="prettyprint linenums">
<code>
SqlCommand command = new SqlCommand();
command.Connection = connection;
</code>
										</pre>
									</div>

									<div class="title">各种类型Command</div>
									<div class="content open">
										<p class="text-strong">SQL语句</p>
										<pre class="prettyprint linenums">
<code>
command.CommandType = CommandType.Text;  // 默认是Text类型            
// 方法1: 使用字面值
command.CommandText = "INSERT INTO authors(au_id, au_name) VALUES('123-45-6789','Barnes')";
 // 方法2: 使用参数
command.CommandText = "INSERT INTO authors (au_id, au_name) VALUES(@au_id,@au_name)";
command.Parameters.Add(new SqlParameter("au_id", "123"));
command.Parameters.AddWithValue("@au_name", "");
</code>
										</pre>	
										<p class="text-remark">注: CommandText可以是多条SQL命令, 中间用";"分隔.</p>

										<p class="text-strong">存储过程</p>
										<pre class="prettyprint linenums">
<code>
command.CommandType = CommandType.StoredProcedure;
command.CommandText = "usp_select_author_titles";
</code>
										</pre>		
										<p class="text-remark">注: 在VS的Server Explorer中可以查看数据库中的存储过程.</p>

										<p class="text-strong">表</p>
										<pre class="prettyprint linenums">
<code>
command.CommandType = CommandType.TableDirect;
command.Text = "表的名字";
</code>
										</pre>		
									</div>

									<div class="title">执行: ExecuteReader(), ExecuteScalar() & ExecuteNonQuery()</div>
									<div class="content open">
										<p>如果程序需要执行面向集合的操作, 比如删除或更新所有满足某一条件的行, 则直接使用一个SQL命令要比使用在C#代码中扩展的SQL命令更有效, 对于大型表来说尤其如此. ADO.NET为执行SQL命令提供了SqlCommand或OleDbCommand对象. 这些对象可以提供直接执行SQL命令的方法.</p>

										<p class="text-strong">1) ExecuteReader: Sends the CommandText to the Connection and builds a SqlDataReader.</p>
										<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
connection.Open();

SqlCommand thisCommand = new SqlCommand("select count(*) from Customers", connection);  // 创建command对象
SqlDataReader dataReader = thisCommand.ExecuteReader();
connection.Close();
</code>
										</pre>	

										<p class="text-strong">2) ExecuteScalar: 获取第一个Cell的值(第一行,第一列)</p>
										<p>如果仅有少量数据, 或者由于某种原因在DataSet中加载了所有的行, 则可以只使用DataTable.Rows.Count. 但是, 如果要计算1 000 000行的大型表中的行数, 则使用ExecuteScalar()方法和select count(*)查询, 要比在内存中加载1 000 000行的效率高得多.</p>
										<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
connection.Open();
 
SqlCommand thisCommand = new SqlCommand("select count(*) from Customers", connection);  // 创建command对象
Object countResult = thisCommand.ExecuteScalar();
Console.WriteLine("Count of Customers = {0}", countResult);

connection.Close();
</code>
										</pre>

										<p class="text-strong">3) ExecuteNonQuery: 不检索数据, 返回操作影响的行数</p>
										<p>类似SQL INSERT, UPDATE和DELETE的数据修改操作也不返回任何数据; 我们对这些命令感兴趣的是修改操作影响的行数, 这个行数使用ExecuteNonQuery()方法返回.</p>	
										<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
connection.Open();
 
SqlCommand thisCommand = new SqlCommand("update Products set UnitPrice = UnitPrice*1.05 where SupplierId = 12", connection);  // 生成command对象
int rowsAffected = thisCommand.ExecuteNonQuery();
Console.WriteLine("Rows Updated = {0}", rowsAffected);

connection.Close();
</code>
										</pre>
									</div>
								</div>
							</div>

							<div class="title">SqlCommandBuilder</div>
							<div class="content closed">
								<p>命令构建器生成SQL命令, 用于根据select命令修改数据(update, insert和delete). 同时, 我们可以用CommandBuilder对象的GetUpdateCommand(), GetInsertCommand()和GetDeleteCommand()方法生成的命令.</p>
								<pre class="prettyprint linenums">
<code>
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID from Customers", connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
</code>
								</pre>
							</div>

							<div class="title">SqlDataReader</div>
							<div class="content closed">
								<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
connection.Open();  // 打开连接. 如果Open失败, 就会抛出SqlException异常
 
SqlCommand thisCommand = connection.CreateCommand();
thisCommand.CommandText = "SELECT CustomerID, CompanyName from Customers";
 
SqlDataReader thisReader = thisCommand.ExecuteReader(); // ExeceuteReader()在数据库中运行SQL命令, 因此也在此生成所有的数据库错误; 它还创建DataReader对象, 用于读取生成的结果
while (thisReader.Read()) { // Read()方法从查询结果中读取一行数据, 如果还有数据要读取, 则返回true; 如果没有, 则返回false
    // DataReader对象提供索引符属性, 这个索引符是重载的, 允许把列引用为按列名称的数组引用: thisReader["CustomerID"],  或者按整数引用:thisReader[0]
    Console.WriteLine("\t{0}\t{1}", thisReader["CustomerID"], thisReader["CompanyName"]); 
}
 
thisReader.Close(); 
connection.Close();
</code>
								</pre>
							</div>

							<div class="title">SqlDataAdapter</div>
							<div class="content closed">
								<div class="list list-number">
									<div class="title">从数据库中取出数据</div>
									<div class="content closed">
										<pre class="prettyprint linenums">
<code>
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID from Customers", connection);

SqlDataAdapter dataAdapter = new SqlDataAdapter();
dataAdapter.SelectCommand = SqlCommand;
dataAdapter.Fill(dataSet, strTable);  // 现在内存中存有数据， 就可以在独立于数据源的情况下处理他们！
</code>
										</pre>	
										<p class="text-remark">注意: Fill方法使用SelectCommand.Connection属性连接数据库. 如果连接已经打开, 数据适配器就使用该连接执行SelectCommand, 并在完成后仍打开连接; 如果连接被关闭, 数据适配器就会打开它, 执行SelectCommand, 完成后再关闭连接.</p>
										<p>
											当调用Fill()方法时, 查询到的数据都被加载到程序的内存中. 这非常适合于小型表, 但不适合于许多商业应用程序中有100 000, 甚至是1 000 000行的大型表.
										</p>
										<p>
											一种方法是, 如果程序仅与一些列交互, 则通过select语句指定需要的列, 限制所使用的列数, 比如: select CustomerID, CompanyName from Customers. <br>
											另一种方法是在SQL select语句上指定where子句, 限制所选择的行数. 例如, 下面的语句: select * from Customers where CustomerID = "ZACZI"
										</p>
										<p>
											我们的目标就是确立下面两方面之间最具效率的均衡: 在运行ADO.NET程序的客户机上本地处理数据, 在运行SQL的服务器上处理搜索任务.
											ADO.NET和C#比SQL更适合于处理复杂运算或导航逻辑. 使用希望处理的表中的数据填充DataSet, 在客户机上执行这种逻辑. 但是使用合适的条件限制从每一张表中选择的行数, 会极大地提高性能(即使数据要在网络上传输, 也是如此), 减少所用的内存.
										</p>
									</div>

									<div class="title">用DataSet读写数据</div>
									<div class="content closed">
										<p>DataSet是ADO.NET中的核心对象, 所有复杂级别的操作都要使用它. DataSet包含一组DataTable对象, 它们表示所操作的数据库表. </p>
										<div class="list list-number">
											<div class="title">用数据填充DataSet</div>
											<div class="content open">
												<p>DataSet的常见操作是用DataAdapter对象的Fill()方法给它填充数据. 为什么Fill()是DataAdapter对象的方法, 而不是DataSet的方法. 因为DataSet是内存中数据的一个抽象表示, 而DataAdapter对象是把DataSet和具体数据库联系起来的对象. </p>
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("Select CustomerID,ContactName from Customers", connection);  // 创建DataAdapter对象
DataSet dataSet = new DataSet();  // 创建要填充数据的DataSet
　
adapter.Fill(dataSet, "Customers");  // 填充DataSet中的DataTable， 表名为Customers
　
foreach (DataRow theRow in dataSet.Tables["Customers"].Rows) {
    Console.WriteLine(theRow["CustomerID"] + "\t" + theRow["ContactName"]);
}
　
// 注意在这个示例中没有明确打开和关闭连接, 因为DataAdapter对象完成了这个工作.
// 而且DataAdapter对象不改变连接的状态， 所以, 如果在DataAdapter对象开始其工作前连接是打开的, 在DataAdapter对象完成其工作后, 连接仍是打开的.
</code>
												</pre>
											</div>

											<div class="title">增</div>
											<div class="content open">
												<p>
													给数据库添加新行的过程如下: <br>
													1) 调用DataAdapter对象的Fill()方法填充DataSet; <br>
													2) 创建一个新的DataRow, 并把它添加到DataSet的Row集合中; <br>
													3) 用DataAdapter对象的Update()方法, 把这个变化返回到数据库中.
												</p>
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID,CompanyName from Customers", connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
DataSet dataSet = new DataSet();
 
adapter.Fill(dataSet, "Customers");
 
DataRow thisRow = dataSet.Tables["Customers"].NewRow();    // 使用DataTable对象的NewRow()方法创建新行对象
thisRow["CustomerID"] = "ZACZI";
thisRow["CompanyName"] = "Zachary Zithers Ltd";
dataSet.Tables["Customers"].Rows.Add(thisRow);            // 把新行添加到Rows集合中

adapter.Update(dataSet, "Customers");    // 更新数据库
</code>
												</pre>
											</div>

											<div class="title">删</div>
											<div class="content open">
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection("Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID, CompanyName from Customers",connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
DataSet dataSet = new DataSet();
 
adapter.Fill(dataSet, "Customers");
 
// Set up keys object for defining primary key
DataColumn[] keys = new DataColumn[1];
keys[0] = dataSet.Tables["Customers"].Columns["CustomerID"];
dataSet.Tables["Customers"].PrimaryKey = keys;
DataRow findRow = dataSet.Tables["Customers"].Rows.Find("ZACZI");
if (findRow == null) {
    return;
}
findRow.Delete(); 

adapter.Update(dataSet, "Customers");
/*
在执行了Delete()方法之后调用DataSet的AcceptChanges()方法时要小心: 这么做仅能删除DataSet中的行, 却不影响数据库中的行, 因为Update()仅影响在Rows集合中找到的行, 遗漏的行会被忽略. 这个问题也适用于Remove()方法: 仅当希望从DataSet的Rows集合中, 而不是从数据库中删除时才调用它.
*/
</code>
												</pre>
											</div>

											<div class="title">查</div>
											<div class="content open">
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID, CompanyName from Customers", connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
DataSet dataSet = new DataSet();
 
adapter.Fill(dataSet, "Customers");
 
// Set up keys object for defining primary key
DataColumn[] keys = new DataColumn[1];
keys[0] = dataSet.Tables["Customers"].Columns["CustomerID"];
dataSet.Tables["Customers"].PrimaryKey = keys;
DataRow findRow = dataSet.Tables["Customers"].Rows.Find("ZACZI"); // Find()的参数: 可以是多列主键的对象数组; 但是在此它仅有一列, 所以只需要传递一个"ZACZI"字符串, 它是我们要查询的CustomerID.
 
if (findRow == null) {
    Console.WriteLine("ZACZI not found in database");
}
</code>
												</pre>
												<p class="text-remark">
													另一种办法是直接从数据库中加载主键, 这不会默认完成. 而是必须在填充DataSet之前设置DataAdapter对象的MissingSchemaAction属性, 显示地告诉ADO.NET加载主键的信息, 如下所示: <br>
													adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey; <br>
													adapter.Fill(dataSet,"Customers"); <br>
													这行代码通过隐式初始化DataTable的PromaryKey属性, 同样可以完成主键的构建. <br>
												</p>
											</div>

											<div class="title">改</div>
											<div class="content open">
												<p>
													在数据库上进行的操作(更新, 插入和删除记录)可以用相同的模式完成: <br>
													1) 调用DataAdapter对象的Fill()方法填充DataSet. <br>
													2) 修改存储在DataSet中的数据(例如, 更新, 插入和删除记录). <br>
													3) 调用DataAdapter对象的Update()方法, 把这个变化返回到数据库中.
												</p>
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID, CompanyName from Customers",connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter); // 创建用于更新数据库的SQL语句, 不必自己手工创建, 可以使用SqlCommandBuilder
DataSet dataSet = new DataSet();
　
adapter.Fill(dataSet, "Customers");    // 将数据填充到DataSet对象中, 表名为Customers
dataSet.Tables["Customers"].Rows[9]["CompanyName"] = "Acme, Inc...";    // 修改数据
adapter.Update(dataSet, "Customers");    // 更新数据库
</code>
												</pre>
											</div>

											<div class="title">多表操作(父表&子表)</div>
											<div class="content closed">
												<p>DataSet的Relations属性是一个DataRelation对象的集合, DataRelation对象表示这个DataSet中表之间的关系, 用于查找和操作相关的表.</p>
												<p>要创建一个新的DataRelation, 可以使用Relations的Add()方法:</p>
												<pre class="prettyprint linenums">
<code>
DataRelation custOrderRel = dataSet.Relations.Add("CustOrders", // 关系名
    dataSet.Tables["Customers"].Columns["CustomerID"], // 父表
    dataSet.Tables["Orders"].Columns["CustomerID"]); // 子表
</code>
												</pre>

												<p class="text-strong">GetChildRows</p>
												<p>
													给定父表中的一行, 如何获取子表中与其对象的所有行? 可以使用DataRow对象的GetChildRows()方法提取这些行. 前面在父表和子表之间创建的DataRelation对象传送给该方法, 返回一个DataRowCollection对象, 它是子表DataTable中相关DataRow对象的集合.
												</p>

												<p class="text-strong">GetParentRow & GetParentRows</p>
												<p>给定子表中的一样, 如何获取父表中与其对象的所有行? 可以使用DataRow对象的GetParentRows()方法提取这些行. 前面在父表和子表之间创建的DataRelation对象传送给该方法, 返回一个DataRowCollection对象, 它是父表DataTable中相关DataRow对象的集合.</p>	
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection("Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
DataSet dataSet = new DataSet();

// 填充Customers表
SqlDataAdapter custAdapter = new SqlDataAdapter("select * from Customers", connection);
custAdapter.Fill(dataSet, "Customers");

// 填充Orders表
SqlDataAdapter orderAdapter = new SqlDataAdapter("select * from Orders", connection);
orderAdapter.Fill(dataSet, "Orders");
 
// 填充Order Details表
SqlDataAdapter detailAdapter = new SqlDataAdapter("select * from [Order Details]", connection);
detailAdapter.Fill(dataSet, "Order Details");
 
// 填充Products表
SqlDataAdapter prodAdapter = new SqlDataAdapter("select * from Products", connection);
prodAdapter.Fill(dataSet, "Products");
 
// Customers & Orders
DataRelation custOrderRel = dataSet.Relations.Add("CustOrders", dataSet.Tables["Customers"].Columns["CustomerID"], dataSet.Tables["Orders"].Columns["CustomerID"]);

// Orders & Order Details
DataRelation orderDetailRel = dataSet.Relations.Add("OrderDetail", dataSet.Tables["Orders"].Columns["OrderID"], dataSet.Tables["Order Details"].Columns["OrderID"]);

// Products & Order Details
DataRelation orderProductRel = dataSet.Relations.Add("OrderProducts", dataSet.Tables["Products"].Columns["ProductID"], dataSet.Tables["Order Details"].Columns["ProductID"]);
 
foreach (DataRow custRow in dataSet.Tables["Customers"].Rows) {
    Console.WriteLine("Customer ID: " + custRow["CustomerID"]);
 
    foreach (DataRow orderRow in custRow.GetChildRows(custOrderRel)) {    // 获取子表记录
        Console.WriteLine("\tOrder ID: " + orderRow["OrderID"]);
        Console.WriteLine("\t\tOrder Date: " + orderRow["OrderDate"]);
 
        foreach (DataRow detailRow in orderRow.GetChildRows(orderDetailRel)) {
            Console.WriteLine("\t\tProduct: " + detailRow.GetParentRow(orderProductRel)["ProductName"]);    // 获取父表记录
            Console.WriteLine("\t\tQuantity: " + detailRow["Quantity"]);
        }
    }
}
</code>
												</pre>

												<p class="text-strong">增加Where限定</p>
												<pre class="prettyprint linenums">
<code>
SqlConnection thisConnection = new SqlConnection("Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
DataSet dataSet = new DataSet();
 
SqlDataAdapter custAdapter = new SqlDataAdapter("select * from Customers where CustomerID = 'ALFKI'", thisConnection);
custAdapter.Fill(dataSet, "Customers");
 
SqlDataAdapter orderAdapter = new SqlDataAdapter("select * from Orders where CustomerID = 'ALFKI'", thisConnection);
orderAdapter.Fill(dataSet, "Orders");
 
SqlDataAdapter detailAdapter = new SqlDataAdapter("select * from [Order Details] where OrderID in (select OrderID from Orders where CustomerID = 'ALFKI')", thisConnection);
detailAdapter.Fill(dataSet, "Order Details");
 
SqlDataAdapter prodAdapter = new SqlDataAdapter("select * from Products", thisConnection);
prodAdapter.Fill(dataSet, "Products");
 
DataRelation custOrderRel = dataSet.Relations.Add("CustOrders", dataSet.Tables["Customers"].Columns["CustomerID"], dataSet.Tables["Orders"].Columns["CustomerID"]);
 
DataRelation orderDetailRel = dataSet.Relations.Add("OrderDetail", dataSet.Tables["Orders"].Columns["OrderID"], dataSet.Tables["Order Details"].Columns["OrderID"]);
 
DataRelation orderProductRel = dataSet.Relations.Add("OrderProducts", dataSet.Tables["Products"].Columns["ProductID"], dataSet.Tables["Order Details"].Columns["ProductID"]);
 
foreach (DataRow custRow in dataSet.Tables["Customers"].Rows) {
    Console.WriteLine("Customer ID: " + custRow["CustomerID"]);
 
    foreach (DataRow orderRow in custRow.GetChildRows(custOrderRel)) {
        Console.WriteLine("\tOrder ID: " + orderRow["OrderID"]);
        Console.WriteLine("\t\tOrder Date: " + orderRow["OrderDate"]);
 
        foreach (DataRow detailRow in orderRow.GetChildRows(orderDetailRel)) {
            Console.WriteLine("\t\tProduct: " + detailRow.GetParentRow(orderProductRel)["ProductName"]);
            Console.WriteLine("\t\tQuantity: " + detailRow["Quantity"]);
        }
    }
}
 
dataSet.WriteXml(@"C:\tmp\nwinddata.xml");
Console.WriteLine(@"Successfully wrote XML output to file c:\tmp\nwinddatam.xml");
 
thisConnection.Close();
Console.WriteLine("Program finished, press Enter/Return to continue");
Console.ReadLine();
</code>
												</pre>
											</div>
										</div>
									</div>
								</div>

							</div>
						</div>
					</div>

					<div class="title">其他数据提供者</div>
					<div class="content closed">
						<p class="text-strong">Oracle .NET数据提供者</p>
						<p>
							如果使用的是Oracle数据库, 内置Oracle.NET驱动程序是最佳选择, .NET Framework就提供了这个驱动程序, 相关类位于System.Data.OracleClient命名空间中！
						</p>
						<p>Oracle本身也提供了一个.NET数据提供者, 引用为Oracle.DatAccess.Client. 它必须从Oracle中单独下载. </p>
						<p>使用数据库销售商提供的.NET数据提供者, 还是.NET Framework提供的.NET数据提供者, 完全取决于读者自己. 一般销售商的提供者能更多地利用数据库产品的特定功能, 但对于基本或初级使用来说, 它们都不错. 两个提供者都能工作, 读者可以使用自己喜欢的那个.
						</p>	

						<p class="text-strong">OLE DB.NET提供者</p>
						<p>对于不是SQL Server或Oracle的数据源(比如Microsoft Access)而言, 可以使用OLE DB.NET数据提供者, 相关类位于System.Data.OleDb命名空间中！</p>
						<p>许多常见数据库的OLE DB提供者会随Windows一起安装, 例如Microsoft Access.</p>
						<p>Access数据库注意事项</p>
						<p>
							SELECT [First Name], [Last Name] FROM Employees WHERE [Last Name] LIKE 'D*' ORDER BY [First Name] DESC; <br>
							1) SQL语句在Access中应以分号结尾. 但是如果忘记添加分号, 也没有关系, 因为Access会自动添加. <br>
							2) 需要把这些字段放在方括号中, 因为这些字段名称包含空格. <br>
							3)　为了使结果更清晰, 可以按升序排列, 在ORDER BY子句中用ASC替代DESC即可. 实际上不需要这么做, 因为升序是默认的排序方式.
						</p>

						<p class="text-strong">ODBC.NET数据提供者</p>
						<p>
							如果数据源没有内置的或OLE DB提供者, 则可以使用ODBC.NET数据提供者, 因为大多数数据库都提供了ODBC接口. ODBC提供者可以通过下面的using指令来引用:
							using System.Data.Odbc;
						</p>

						<p class="text-strong">其他内置的.NET数据提供者</p>
						<p>
							如果数据库有专用的内置.NET数据提供者, 就可以使用它. 其他许多数据库销售商和第三方公司也提供了内置.NET数据提供者, 选择内置提供者还是使用通用的ODBC提供者取决于程序运行的环境. 如果可移植性的要求高于性能, 就应使用通用的ODBC提供者. 如果性能要求高或者要充分利用某个数据库的功能, 就应使用内置.NET数据提供者.
						</p>

						<p>注: 在每一个.NET数据提供者中定义的对象, 其名称前带有特定提供者的名称. 因此, 用于OLE DB提供者的连接对象就是OleDbConnection, 用于SQL Server .NET提供者的类型就是SqlConnection.</p>
					</div>
				</div>
			</div>

			<div class="title">用户对象</div>
			<div class="content open">
				<div class="list list-number">
					<div class="title">DataSet - 数据库</div>
					<div class="content closed">
						<p>表示一组相关表. 有了此对象, 就可以快速从每一个表中获取所需的数据, 当与服务器断开时检查并修改数据, 然后在另一个操作中使用这些修改的数据更新服务器.</p>
						<p>
							<span class="text-strong">Tables属性</span><br>
							DataSet对象有一个Tables属性, 它是DataSet中所有DataTable对象的集合. Tables的类型是DataTableCollection, 它有一个重载的索引符, 于是可以用两种方式访问每个DataTable: <br>
							1) 按表名访问: dataSet.Tables["Customers"] <br>
							2) 按索引访问: dataSet.Tables[0]
						</p>	
					</div>

					<div class="title">DataTable - 表</div>
					<div class="content closed">
						<p>
							表示DataSet中的一个表. DataTable对象允许访问其中的行(DataRow)和列(DataColumn)
						</p>
						<p>
							<span class="text-strong">Rows属性</span><br>
							在每个DataTable中, 都有一个Rows属性, 它是DataRow对象的集合. Rows的类型是DataRowCollection, 是一个有序列表, 按行号排序. 所以: <br>
							myDataSet.Tables["Customers"].Rows[n]
						</p>
						<p>
							<span class="text-strong">DataRow对象</span><br>
							DataRow对象有一个重载的索引符属性, 允许按列名访问各个列. 于是: <br>
							this.DataSet.Tables["Customers"].Rows[n]["CompanyName"]
						</p>
					</div>

					<div class="title">DataView - 视图</div>
					<div class="content closed">
						<pre class="prettyprint linenums">
<code>
DataView objDataView = new DataView(objDataSet.Tables("authors"));

// 排序
objDataView.Sort = "au_fname, au_lname"    升序排列
objDataView.Sort = "au_fname, au_lname DESC"    降序排列    (类似SQL ORDER BY子句)

// 过滤
objDataView.RowFilter = "au_lname = 'Green'"    (类似SQL WHERE子句)
objDataView.RowFilter = "au_lname <> 'Green'"
objDataView.RowFilter = "au_lname <> 'Green' AND au_fname LIKE 'D*'"

// 查找
dataView.Sort = "au_fname";    // 先排序
intPosition = objDataView.Find("Ann");    // 后查找(不区 だ大小写)

Object[] arrValues = new Object[2] { "Simon", "Watts" };
int intPosition = dataView.Find(arrValues);

// Find方法执行字符完全匹配的查找.
// 1) 如果找到一个匹配的数据, Find方法将返回该记录在DataView中的位置; 否则, 返回-1.
// 2) Find方法找到一个匹配的数据后, 将停止查找, 仅仅返回第一个匹配数据的位置.
</code>
						</pre>	
					</div>

					<div class="title">DataRelation - 数据表关系</div>
					<div class="content closed">
						<p>
							表示通过共享列而发生关系的两个表之间的关系. 例如Orders表中的CustomerID列标识发出订单的客户. 于是, 可以创建DataRelation对象, 通过共享列CustomerID建立Customers和Orders表之间的关系.
						</p>
					</div>
				</div>

			</div>

			<div class="title">XML & ADO.NET</div>
			<div class="content closed">
				<p>
					ADO.NET中的XML支持主要集中于DataSet对象, DataSet有7个用于处理XML的方法, 其中最易于使用的方法是: <br>
					1) WriteXml(), 它将DataSet的内容以XML文档的形式写出. <br>
					2) ReadXml()也可以用于将XML文件的内容读取到DataSet中. ReadXml()方法在DataSet中创建一个DataTable对象, 并使用XML文件中的数据填充它. 而且, 所创建的DataTable采用XML文档中的根元素命名.
				</p>
			</div>
		</div>
    </div>

	<!--ORM - Dapper-->
    <div class="title">ORM - Dapper</div>
    <div class="content closed">        

        <!--Execute a query and map the results to a strongly typed List-->
        <div class="list list-square">
            <div class="title">Execute a query and map the results to a strongly typed List - Query()</div>
            <div class="content closed">
                <pre class="prettyprint linenums lang-cs">
<code>
// 数据库实体类
public class Dog
{
    public int? Age { get; set; }
    public Guid Id { get; set; }
    public string Name { get; set; }
    public float? Weight { get; set; }

    public int IgnoredProperty { get { return 1; } }
}            
            
// 查询
var guid = Guid.NewGuid();
var dog = connection.Query&lt;Dog>("select Age = @Age, Id = @Id", new { Age = (int?)null, Id = guid });

Assert.Equal(1, dog.Count());
Assert.Null(dog.First().Age);
Assert.Equal(1, dog.ElementAt(0).Age);
Assert.Equal(guid, dog.First().Id);
</code>
				</pre>
            </div>

            <!--Execute a query and map it to a list of dynamic objects-->
            <div class="title">Execute a query and map it to a list of dynamic objects - Query()</div>
            <div class="content closed">
                <pre class="prettyprint linenums lang-cs">
<code>
var guid = Guid.NewGuid();
var dog = connection.Query("select Age = @Age, Id = @Id", new { Age = (int?)null, Id = guid });

Assert.Equal(1, dog.Count());
Assert.Null(dog.First().Age);
Assert.Equal(1, dog.ElementAt(0).Age);
Assert.Equal(guid, dog.First().Id);
</code>
				</pre>
            </div>

            <!--Execute a Command that returns no results-->
            <div class="title">Execute a Command that returns no results - Execute()</div>
            <div class="content closed">
                <pre class="prettyprint linenums lang-cs">
<code>
var count = connection.Execute(@"
  set nocount on 
  create table #t(i int) 
  set nocount off 
  insert #t 
  select @a a union all select @b 
  set nocount on 
  drop table #t", new {a=1, b=2 });
Assert.Equal(2, count);
</code>
				</pre>
            </div>

            <!--Execute a Command multiple times-->
            <div class="title">Execute a Command multiple times - Execute()</div>
            <div class="content closed">
                <pre class="prettyprint linenums lang-cs">
<code>
var count = connection.Execute(@"insert MyTable(colA, colB) values (@a, @b)",
    new[] { new { a=1, b=1 }, new { a=2, b=2 }, new { a=3, b=3 } }
  );
Assert.Equal(3, count); // 3 rows inserted: "1,1", "2,2" and "3,3"
</code>
				</pre>
            </div>
        </div>

		<p>
			参考资料: 
			<a href="https://github.com/StackExchange/Dapper">官网</a>, 
			<a href="http://www.cnblogs.com/Sinte-Beuve/p/4231053.html">Dapper的基本使用</a>
		</p>
    </div>

	<!--ORM - Enity Framework-->
    <div class="title">ORM - Entity Framework</div>
    <div class="content closed">
        <a href="https://msdn.microsoft.com/en-us/library/aa937723(v=vs.113).aspx">官方资料</a><br>
        <a href="http://www.cnblogs.com/wujingtao/p/5401113.html">Entity Framework 6快速入门</a>
    </div>

	<div class="title">其他</div>
	<div class="content closed">
		<div class="list list-number">
			<div class="title">数据访问简史</div>
			<div class="content closed">
				<p class="text-strong">1. 数据库专用函数组</p>
				<p>
					在开发第一个数据库系统时, 如Oracle或者IBM的DB2, 开发人员希望该系统可以根据需要访问数据, 使用专用于数据库系统的函数组. 每个系统都有自己的函数库, 例如Oracle的Oracle Call Interface, Sybase SQL Server的DBLib. 这样其程序就能快速访问数据, 因为它们与数据库可以直接通信. 但是, 使用数据库的程序员必须熟悉所用数据库的不同函数库, 导致数据驱动的应用程序编写起来非常复杂. 而且, 如果公司改变它使用的数据库系统, 其应用程序也必须从开开始编写.
				</p>

				<p class="text-strong">2. ODBC</p>
				<p>
					这个问题使用Open Database Connectivity(ODBC)得到了解决. ODBC是Microsoft联合其他公司在20世纪90年代开发的. 它提供了一个通用的函数组, 开发人员可以在任意数据库系统中使用这个函数组. 这些函数可以用特定数据库系统的驱动程序转换为专用于该数据库的函数.
				</p>
				<p>
					ODBC还解决了专用数据库的主要问题, 开发人员只需要知道如何使用一组函数(ODBC函数)即可, 如果公司改变了其数据库系统, 只需在应用程序中修改用于连接数据库的代码. 但是, 还有一个问题. 目前无纸办公仍是一个理想, 公司要把大量的电子数据存储在许多地方: 电子邮件, Web页面, Project 2000文件等, ODBC适合于访问传统数据库中的数据, 但不能访问其他类型的数据, 这些数据并不存储在表格的行和列中, 可能根本就没有一致的结构.	
				</p>

				<p class="text-strong">3. OLE DB</p>
				<p>
					这个问题的答案由OLE DB提供.OLE DB的工作方式类似于ODBC, 它在数据库和需要访问数据的应用程序之间提供了一层抽象. 客户应用程序与数据源通信, 数据源可以是传统的数据库, 也可以存储数据的其他地方, 通过OLE DB提供者与该数据源通信. 数据源中的数据以表格的形式显示给应用程序, 就好像数据来自数据库一样. 由于OLE DB允许访问已有ODBC驱动程序提供的数据, 所以可以用于访问ODBC支持的所有数据库. 如后面所述, ADO.NET支持OLE DB和ODBC的方式非常类型.	
				</p>

				<p class="text-strong">4. ADO</p>
				<p>
					最后一个要提及的旧式数据访问技术是ActiveX Data Objects(ADO). ADO只是一个瘦层, 位于OLE DB的上面, 允许用高级语言如Visual Basic编写的程序访问OLE DB数据.
				</p>

				<p class="text-strong">5. ADO.NET</p>
				<p>
					ADO.NET是与C#和.NET Framework一起使用的类集的名称, 用于以关系型的, 面向表的格式访问数据. 这包括关系数据库, 比如Microsoft Access和SQL Server, 以及其他数据库, 甚至还包括非关系数据库. ADO.NET集成到.NET Framework中, 可用于任何.NET语言. <br>
					ADO.NET提供了一个断开的体系结构, 也就是说, 应用程序与数据库连接后, 检索数据并把它们保存在内存中, 然后就断开与数据库的连接, 接着处理数据在内存中的副本. 如果数据库需要用对内存副本所作的修改进行更新, 就建立一个新的连接, 并更新数据库. <br>
					使用断开的体系结构有很多好处, 其中最重要的是允许应用程序按比例增长. 这意味着数据库在支持100个用户时和支持10个用户时表现得一样好. 应用程序连接数据库的时间只是满足检索或更新数据的需要, 之后就断开连接, 因此释放了可用的数据库连接, 这样就可以实现与应用程序其他实例的连接, 或与使用同一数据库的其他应用程序的连接.
				</p>
			</div>

			<div class="title">Server Explorer</div>
			<div class="content closed">
				<p>
					在Visual Studio 2005 View菜单, 选择Server Explorer菜单, 将显示Server Explorer窗口. 在Server Explorer中可以创建数据库连接, 浏览数据.
				</p>
			</div>

			<div class="title">数据源</div>
			<div class="content closed">
				<p>
					在Visual Studio 2005 Data菜单中, 选择Show Data Sources, 将显示Data Sources窗口. Data Sources窗口中显示了当前所有的数据源, 可以在这里添加新的数据源. 数据源可以是数据库, 文件, Web服务或一般的对象.
				</p>
				<p>
					直接拖放Data Sources中的对象到窗体上即可, VS会帮你处理剩下的事情.
				</p>
				<p>
					一般来说, VS会自动生成一个Save按钮, 并且自动生成Save代码, 所以就不需要添加代码了. 但是, 可以添加一些代码来验证用户对数据进行的修改, 再把这些变动保存到数据库中. 例如:
				</p>
				<pre class="prettyprint linenums">
<code>
private void customersBindingNavigatorSaveItem_Click(object sender, EventArgs e)
{
    if (this.customerIDTextBox.Text.Length != 5) {
        MessageBox.Show(this, "CustomerID must be 5 characters long", "Save");
        return;
    }
 
    this.Validate();
    this.customersBindingSource.EndEdit();
    this.customersTableAdapter.Update(this.northwindDataSet.Customers);
}
</code>
				</pre>	
			</div>

			<div class="title">补装Express</div>
			<div class="content closed">
				<p>
					SQL Express是随着VS2005一起安装的一个软件包, 但默认情况下不安装它. 如果没有选中安装SQL Express, 就可以进入下面的目录安装它:
					C:\Program Files\Microsoft Visual Studio 8\SDK\v2.0\BootStrapper\Packages\SqlExpress\en, 在这个位置执行安装可执行文件: Sqlexpr.exe, 来安装安装Northwind示例数据库.
				</p>
				<p>
					SQL Server Northwind示例数据库包含在.NET Framework v2.0 SDK示例安装区域的Visual Studio 2005中的Quickstart示例里. 如果没有把Quickstart示例选择为要安装的内容 就要再次运行VS2005安装程序, 选择.NET Framework SDK | Quickstart Samples.
				</p>
				<p>
					在安装Quickstart示例后, 要把Northwind示例安装到SQL Express中, 需要执行命令提示(Start|Run|cmd), 把目录改为示例安装区域: <br>
					cd "C:\Program Files\Microsoft Visual Studio 8\SDK\v2.0\Samples\Setup"
				</p>
				<p>
					如果已在计算机上安装了SQL Express, 就运行osql实用程序(位于:C:\Program Files\Microsoflt SQL Server\90\Tools\Binn), 安装实例数据: <br>
					osql -E -S (local)\sqlexpress -i instnwnd.sql
				</p>
				<p>
					注意: <br>
					-E标记告诉SQL(Windows登录)用作SQL Server用户.<br>
					-S标记表示SQL Sever的名称, 其中包括服务器名称和实例名. sqlexpress是一个实例名称, 在一台机器上可能运行了SQL Server的多个版本, 它们就使用唯一的实例名来区分. sqlexpress是SQL Express安装程序创建的默认实例. 服务器名(本地)是本地服务器的通用名称, 即SQL Server在同一台机器上运行为osql或VS2005(桌面计算机). 可以用实际的机器名称代替(本地). 例如, 如果膝上型电脑称为roadrunner, 就可以用-S roadrunner\sqlexpress调用osql, 它表示运行在roadrunner机器上的SQL Server示例sqlexpress.

				</p>
			</div>
		</div>
	</div>
</div>
{include file="template/footer" /}