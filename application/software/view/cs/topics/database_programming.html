{include file="template/header" title="C# 数据库编程" /}
<div class="list list-number">
	<!--ADO.NET-->
    <div class="title">ADO.NET</div>
    <div class="content open">
		<div class="list list-number">
			<div class="title">数据提供者</div>
			<div class="content open">
				<div class="list list-number">
					<div class="title">概述</div>
					<div class="content open">
						<p>数据提供者对象用于每一种类型的数据源, 专用于提供者的对象完成数据源中实际的读取和写入工作.</p>
						<table class="table table-bordered table-sm w-50">
							<tbody>
								<tr>
									<th>1. Connection</th>
									<td>访问数据库之前, 必须先连接!</td>
								</tr>
								<tr>
									<th>2. Command</th>
									<td>可以使用此对象给数据源发出命令, 比如"select * from Customers"查询Customers表中的数据.</td>
								</tr>
								<tr>
									<th>3. CommandBuilder</th>
									<td>此对象用于构建SQL命令, 在基于单一表查询的对象中进行数据修改.</td>
								</tr>
								<tr>
									<th>4. DataReader</th>
									<td>可以从数据源中读取仅能向前和只读的数据流(比如找到的用户集合). 对于简单地读取数据来说, 此对象的性能最好. </td>
								</tr>
								<tr>
									<th>5. DataAdapter</th>
									<td>可以执行针对数据源的各种操作, 包括更新变动的数据, 填充DataSet对象以及其他操作.</td>
								</tr>
							</tbody>
						</table>
					</div>

					<div class="title">MS SQL Server数据提供者</div>
					<div class="content open">
						<div class="list list-number">
							<div class="title">SqlConnection</div>
							<div class="content closed">
								<pre class="prettyprint linenums">
<code>
// 对应SqlConnection对象
SqlConnection connection = new SqlConnection("Server=localhost;Database=pubs;User ID=sa;Password=vbdotnet"); // 方法1
SqlConnection connection = new SqlConnection(); // 方法2
connection.ConnectionString = "Server=localhost;Database=pubs;User ID=sa;Password=vbdotnet";

// 打开&关闭连接
connection.Open();
connection.Close();
</code>
								</pre>
							</div>

							<div class="title">SqlCommand</div>
							<div class="content closed">
								<div class="list list-number">
									<div class="title">定义Command</div>
									<div class="content open">
										<pre class="prettyprint linenums">
<code>
SqlCommand command = new SqlCommand();
command.Connection = connection;
</code>
										</pre>
									</div>

									<div class="title">各种类型Command</div>
									<div class="content open">
										<p class="text-strong">SQL语句</p>
										<pre class="prettyprint linenums">
<code>
command.CommandType = CommandType.Text;  // 默认是Text类型            
// 方法1: 使用字面值
command.CommandText = "INSERT INTO authors(au_id, au_name) VALUES('123-45-6789','Barnes')";
 // 方法2: 使用参数
command.CommandText = "INSERT INTO authors (au_id, au_name) VALUES(@au_id,@au_name)";
command.Parameters.Add(new SqlParameter("au_id", "123"));
command.Parameters.AddWithValue("@au_name", "");
</code>
										</pre>	
										<p class="text-remark">注: CommandText可以是多条SQL命令, 中间用";"分隔.</p>

										<p class="text-strong">存储过程</p>
										<pre class="prettyprint linenums">
<code>
command.CommandType = CommandType.StoredProcedure;
command.CommandText = "usp_select_author_titles";
</code>
										</pre>		
										<p class="text-remark">注: 在VS的Server Explorer中可以查看数据库中的存储过程.</p>

										<p class="text-strong">表</p>
										<pre class="prettyprint linenums">
<code>
command.CommandType = CommandType.TableDirect;
command.Text = "表的名字";
</code>
										</pre>		
									</div>

									<div class="title">执行: ExecuteReader(), ExecuteScalar() & ExecuteNonQuery()</div>
									<div class="content open">
										<p>如果程序需要执行面向集合的操作, 比如删除或更新所有满足某一条件的行, 则直接使用一个SQL命令要比使用在C#代码中扩展的SQL命令更有效, 对于大型表来说尤其如此. ADO.NET为执行SQL命令提供了SqlCommand或OleDbCommand对象. 这些对象可以提供直接执行SQL命令的方法.</p>

										<p class="text-strong">1) ExecuteReader: Sends the CommandText to the Connection and builds a SqlDataReader.</p>
										<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
connection.Open();

SqlCommand thisCommand = new SqlCommand("select count(*) from Customers", connection);  // 创建command对象
SqlDataReader dataReader = thisCommand.ExecuteReader();
connection.Close();
</code>
										</pre>	

										<p class="text-strong">2) ExecuteScalar: 获取第一个Cell的值(第一行,第一列)</p>
										<p>如果仅有少量数据, 或者由于某种原因在DataSet中加载了所有的行, 则可以只使用DataTable.Rows.Count. 但是, 如果要计算1 000 000行的大型表中的行数, 则使用ExecuteScalar()方法和select count(*)查询, 要比在内存中加载1 000 000行的效率高得多.</p>
										<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
connection.Open();
 
SqlCommand thisCommand = new SqlCommand("select count(*) from Customers", connection);  // 创建command对象
Object countResult = thisCommand.ExecuteScalar();
Console.WriteLine("Count of Customers = {0}", countResult);

connection.Close();
</code>
										</pre>

										<p class="text-strong">3) ExecuteNonQuery: 不检索数据, 返回操作影响的行数</p>
										<p>类似SQL INSERT, UPDATE和DELETE的数据修改操作也不返回任何数据; 我们对这些命令感兴趣的是修改操作影响的行数, 这个行数使用ExecuteNonQuery()方法返回.</p>	
										<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
connection.Open();
 
SqlCommand thisCommand = new SqlCommand("update Products set UnitPrice = UnitPrice*1.05 where SupplierId = 12", connection);  // 生成command对象
int rowsAffected = thisCommand.ExecuteNonQuery();
Console.WriteLine("Rows Updated = {0}", rowsAffected);

connection.Close();
</code>
										</pre>
									</div>
								</div>
							</div>

							<div class="title">SqlCommandBuilder</div>
							<div class="content closed">
								<p>命令构建器生成SQL命令, 用于根据select命令修改数据(update, insert和delete). 同时, 我们可以用CommandBuilder对象的GetUpdateCommand(), GetInsertCommand()和GetDeleteCommand()方法生成的命令.</p>
								<pre class="prettyprint linenums">
<code>
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID from Customers", connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
</code>
								</pre>
							</div>

							<div class="title">SqlDataReader</div>
							<div class="content closed">
								<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
connection.Open();  // 打开连接. 如果Open失败, 就会抛出SqlException异常
 
SqlCommand thisCommand = connection.CreateCommand();
thisCommand.CommandText = "SELECT CustomerID, CompanyName from Customers";
 
SqlDataReader thisReader = thisCommand.ExecuteReader(); // ExeceuteReader()在数据库中运行SQL命令, 因此也在此生成所有的数据库错误; 它还创建DataReader对象, 用于读取生成的结果
while (thisReader.Read()) { // Read()方法从查询结果中读取一行数据, 如果还有数据要读取, 则返回true; 如果没有, 则返回false
    // DataReader对象提供索引符属性, 这个索引符是重载的, 允许把列引用为按列名称的数组引用: thisReader["CustomerID"],  或者按整数引用:thisReader[0]
    Console.WriteLine("\t{0}\t{1}", thisReader["CustomerID"], thisReader["CompanyName"]); 
}
 
thisReader.Close(); 
connection.Close();
</code>
								</pre>
							</div>

							<div class="title">SqlDataAdapter</div>
							<div class="content closed">
								<div class="list list-number">
									<div class="title">从数据库中取出数据</div>
									<div class="content closed">
										<pre class="prettyprint linenums">
<code>
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID from Customers", connection);

SqlDataAdapter dataAdapter = new SqlDataAdapter();
dataAdapter.SelectCommand = SqlCommand;
dataAdapter.Fill(dataSet, strTable);  // 现在内存中存有数据， 就可以在独立于数据源的情况下处理他们！
</code>
										</pre>	
										<p class="text-remark">注意: Fill方法使用SelectCommand.Connection属性连接数据库. 如果连接已经打开, 数据适配器就使用该连接执行SelectCommand, 并在完成后仍打开连接; 如果连接被关闭, 数据适配器就会打开它, 执行SelectCommand, 完成后再关闭连接.</p>
										<p>
											当调用Fill()方法时, 查询到的数据都被加载到程序的内存中. 这非常适合于小型表, 但不适合于许多商业应用程序中有100 000, 甚至是1 000 000行的大型表.
										</p>
										<p>
											一种方法是, 如果程序仅与一些列交互, 则通过select语句指定需要的列, 限制所使用的列数, 比如: select CustomerID, CompanyName from Customers. <br>
											另一种方法是在SQL select语句上指定where子句, 限制所选择的行数. 例如, 下面的语句: select * from Customers where CustomerID = "ZACZI"
										</p>
										<p>
											我们的目标就是确立下面两方面之间最具效率的均衡: 在运行ADO.NET程序的客户机上本地处理数据, 在运行SQL的服务器上处理搜索任务.
											ADO.NET和C#比SQL更适合于处理复杂运算或导航逻辑. 使用希望处理的表中的数据填充DataSet, 在客户机上执行这种逻辑. 但是使用合适的条件限制从每一张表中选择的行数, 会极大地提高性能(即使数据要在网络上传输, 也是如此), 减少所用的内存.
										</p>
									</div>

									<div class="title">用DataSet读写数据</div>
									<div class="content closed">
										<p>DataSet是ADO.NET中的核心对象, 所有复杂级别的操作都要使用它. DataSet包含一组DataTable对象, 它们表示所操作的数据库表. </p>
										<div class="list list-number">
											<div class="title">用数据填充DataSet</div>
											<div class="content open">
												<p>DataSet的常见操作是用DataAdapter对象的Fill()方法给它填充数据. 为什么Fill()是DataAdapter对象的方法, 而不是DataSet的方法. 因为DataSet是内存中数据的一个抽象表示, 而DataAdapter对象是把DataSet和具体数据库联系起来的对象. </p>
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("Select CustomerID,ContactName from Customers", connection);  // 创建DataAdapter对象
DataSet dataSet = new DataSet();  // 创建要填充数据的DataSet
　
adapter.Fill(dataSet, "Customers");  // 填充DataSet中的DataTable， 表名为Customers
　
foreach (DataRow theRow in dataSet.Tables["Customers"].Rows) {
    Console.WriteLine(theRow["CustomerID"] + "\t" + theRow["ContactName"]);
}
　
// 注意在这个示例中没有明确打开和关闭连接, 因为DataAdapter对象完成了这个工作.
// 而且DataAdapter对象不改变连接的状态， 所以, 如果在DataAdapter对象开始其工作前连接是打开的, 在DataAdapter对象完成其工作后, 连接仍是打开的.
</code>
												</pre>
											</div>

											<div class="title">增</div>
											<div class="content open">
												<p>
													给数据库添加新行的过程如下: <br>
													1) 调用DataAdapter对象的Fill()方法填充DataSet; <br>
													2) 创建一个新的DataRow, 并把它添加到DataSet的Row集合中; <br>
													3) 用DataAdapter对象的Update()方法, 把这个变化返回到数据库中.
												</p>
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID,CompanyName from Customers", connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
DataSet dataSet = new DataSet();
 
adapter.Fill(dataSet, "Customers");
 
DataRow thisRow = dataSet.Tables["Customers"].NewRow();    // 使用DataTable对象的NewRow()方法创建新行对象
thisRow["CustomerID"] = "ZACZI";
thisRow["CompanyName"] = "Zachary Zithers Ltd";
dataSet.Tables["Customers"].Rows.Add(thisRow);            // 把新行添加到Rows集合中

adapter.Update(dataSet, "Customers");    // 更新数据库
</code>
												</pre>
											</div>

											<div class="title">删</div>
											<div class="content open">
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection("Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID, CompanyName from Customers",connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
DataSet dataSet = new DataSet();
 
adapter.Fill(dataSet, "Customers");
 
// Set up keys object for defining primary key
DataColumn[] keys = new DataColumn[1];
keys[0] = dataSet.Tables["Customers"].Columns["CustomerID"];
dataSet.Tables["Customers"].PrimaryKey = keys;
DataRow findRow = dataSet.Tables["Customers"].Rows.Find("ZACZI");
if (findRow == null) {
    return;
}
findRow.Delete(); 

adapter.Update(dataSet, "Customers");
/*
在执行了Delete()方法之后调用DataSet的AcceptChanges()方法时要小心: 这么做仅能删除DataSet中的行, 却不影响数据库中的行, 因为Update()仅影响在Rows集合中找到的行, 遗漏的行会被忽略. 这个问题也适用于Remove()方法: 仅当希望从DataSet的Rows集合中, 而不是从数据库中删除时才调用它.
*/
</code>
												</pre>
											</div>

											<div class="title">查</div>
											<div class="content open">
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID, CompanyName from Customers", connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
DataSet dataSet = new DataSet();
 
adapter.Fill(dataSet, "Customers");
 
// Set up keys object for defining primary key
DataColumn[] keys = new DataColumn[1];
keys[0] = dataSet.Tables["Customers"].Columns["CustomerID"];
dataSet.Tables["Customers"].PrimaryKey = keys;
DataRow findRow = dataSet.Tables["Customers"].Rows.Find("ZACZI"); // Find()的参数: 可以是多列主键的对象数组; 但是在此它仅有一列, 所以只需要传递一个"ZACZI"字符串, 它是我们要查询的CustomerID.
 
if (findRow == null) {
    Console.WriteLine("ZACZI not found in database");
}
</code>
												</pre>
												<p class="text-remark">
													另一种办法是直接从数据库中加载主键, 这不会默认完成. 而是必须在填充DataSet之前设置DataAdapter对象的MissingSchemaAction属性, 显示地告诉ADO.NET加载主键的信息, 如下所示: <br>
													adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey; <br>
													adapter.Fill(dataSet,"Customers"); <br>
													这行代码通过隐式初始化DataTable的PromaryKey属性, 同样可以完成主键的构建. <br>
												</p>
											</div>

											<div class="title">改</div>
											<div class="content open">
												<p>
													在数据库上进行的操作(更新, 插入和删除记录)可以用相同的模式完成: <br>
													1) 调用DataAdapter对象的Fill()方法填充DataSet. <br>
													2) 修改存储在DataSet中的数据(例如, 更新, 插入和删除记录). <br>
													3) 调用DataAdapter对象的Update()方法, 把这个变化返回到数据库中.
												</p>
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection(@"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
SqlDataAdapter adapter = new SqlDataAdapter("select CustomerID, CompanyName from Customers",connection);
SqlCommandBuilder builder = new SqlCommandBuilder(adapter); // 创建用于更新数据库的SQL语句, 不必自己手工创建, 可以使用SqlCommandBuilder
DataSet dataSet = new DataSet();
　
adapter.Fill(dataSet, "Customers");    // 将数据填充到DataSet对象中, 表名为Customers
dataSet.Tables["Customers"].Rows[9]["CompanyName"] = "Acme, Inc...";    // 修改数据
adapter.Update(dataSet, "Customers");    // 更新数据库
</code>
												</pre>
											</div>

											<div class="title">多表操作(父表&子表)</div>
											<div class="content closed">
												<p>DataSet的Relations属性是一个DataRelation对象的集合, DataRelation对象表示这个DataSet中表之间的关系, 用于查找和操作相关的表.</p>
												<p>要创建一个新的DataRelation, 可以使用Relations的Add()方法:</p>
												<pre class="prettyprint linenums">
<code>
DataRelation custOrderRel = dataSet.Relations.Add("CustOrders", // 关系名
    dataSet.Tables["Customers"].Columns["CustomerID"], // 父表
    dataSet.Tables["Orders"].Columns["CustomerID"]); // 子表
</code>
												</pre>

												<p class="text-strong">GetChildRows</p>
												<p>
													给定父表中的一行, 如何获取子表中与其对象的所有行? 可以使用DataRow对象的GetChildRows()方法提取这些行. 前面在父表和子表之间创建的DataRelation对象传送给该方法, 返回一个DataRowCollection对象, 它是子表DataTable中相关DataRow对象的集合.
												</p>

												<p class="text-strong">GetParentRow & GetParentRows</p>
												<p>给定子表中的一样, 如何获取父表中与其对象的所有行? 可以使用DataRow对象的GetParentRows()方法提取这些行. 前面在父表和子表之间创建的DataRelation对象传送给该方法, 返回一个DataRowCollection对象, 它是父表DataTable中相关DataRow对象的集合.</p>	
												<pre class="prettyprint linenums">
<code>
SqlConnection connection = new SqlConnection("Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
DataSet dataSet = new DataSet();

// 填充Customers表
SqlDataAdapter custAdapter = new SqlDataAdapter("select * from Customers", connection);
custAdapter.Fill(dataSet, "Customers");

// 填充Orders表
SqlDataAdapter orderAdapter = new SqlDataAdapter("select * from Orders", connection);
orderAdapter.Fill(dataSet, "Orders");
 
// 填充Order Details表
SqlDataAdapter detailAdapter = new SqlDataAdapter("select * from [Order Details]", connection);
detailAdapter.Fill(dataSet, "Order Details");
 
// 填充Products表
SqlDataAdapter prodAdapter = new SqlDataAdapter("select * from Products", connection);
prodAdapter.Fill(dataSet, "Products");
 
// Customers & Orders
DataRelation custOrderRel = dataSet.Relations.Add("CustOrders", dataSet.Tables["Customers"].Columns["CustomerID"], dataSet.Tables["Orders"].Columns["CustomerID"]);

// Orders & Order Details
DataRelation orderDetailRel = dataSet.Relations.Add("OrderDetail", dataSet.Tables["Orders"].Columns["OrderID"], dataSet.Tables["Order Details"].Columns["OrderID"]);

// Products & Order Details
DataRelation orderProductRel = dataSet.Relations.Add("OrderProducts", dataSet.Tables["Products"].Columns["ProductID"], dataSet.Tables["Order Details"].Columns["ProductID"]);
 
foreach (DataRow custRow in dataSet.Tables["Customers"].Rows) {
    Console.WriteLine("Customer ID: " + custRow["CustomerID"]);
 
    foreach (DataRow orderRow in custRow.GetChildRows(custOrderRel)) {    // 获取子表记录
        Console.WriteLine("\tOrder ID: " + orderRow["OrderID"]);
        Console.WriteLine("\t\tOrder Date: " + orderRow["OrderDate"]);
 
        foreach (DataRow detailRow in orderRow.GetChildRows(orderDetailRel)) {
            Console.WriteLine("\t\tProduct: " + detailRow.GetParentRow(orderProductRel)["ProductName"]);    // 获取父表记录
            Console.WriteLine("\t\tQuantity: " + detailRow["Quantity"]);
        }
    }
}
</code>
												</pre>

												<p class="text-strong">增加Where限定</p>
												<pre class="prettyprint linenums">
<code>
SqlConnection thisConnection = new SqlConnection("Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True");
DataSet dataSet = new DataSet();
 
SqlDataAdapter custAdapter = new SqlDataAdapter("select * from Customers where CustomerID = 'ALFKI'", thisConnection);
custAdapter.Fill(dataSet, "Customers");
 
SqlDataAdapter orderAdapter = new SqlDataAdapter("select * from Orders where CustomerID = 'ALFKI'", thisConnection);
orderAdapter.Fill(dataSet, "Orders");
 
SqlDataAdapter detailAdapter = new SqlDataAdapter("select * from [Order Details] where OrderID in (select OrderID from Orders where CustomerID = 'ALFKI')", thisConnection);
detailAdapter.Fill(dataSet, "Order Details");
 
SqlDataAdapter prodAdapter = new SqlDataAdapter("select * from Products", thisConnection);
prodAdapter.Fill(dataSet, "Products");
 
DataRelation custOrderRel = dataSet.Relations.Add("CustOrders", dataSet.Tables["Customers"].Columns["CustomerID"], dataSet.Tables["Orders"].Columns["CustomerID"]);
 
DataRelation orderDetailRel = dataSet.Relations.Add("OrderDetail", dataSet.Tables["Orders"].Columns["OrderID"], dataSet.Tables["Order Details"].Columns["OrderID"]);
 
DataRelation orderProductRel = dataSet.Relations.Add("OrderProducts", dataSet.Tables["Products"].Columns["ProductID"], dataSet.Tables["Order Details"].Columns["ProductID"]);
 
foreach (DataRow custRow in dataSet.Tables["Customers"].Rows) {
    Console.WriteLine("Customer ID: " + custRow["CustomerID"]);
 
    foreach (DataRow orderRow in custRow.GetChildRows(custOrderRel)) {
        Console.WriteLine("\tOrder ID: " + orderRow["OrderID"]);
        Console.WriteLine("\t\tOrder Date: " + orderRow["OrderDate"]);
 
        foreach (DataRow detailRow in orderRow.GetChildRows(orderDetailRel)) {
            Console.WriteLine("\t\tProduct: " + detailRow.GetParentRow(orderProductRel)["ProductName"]);
            Console.WriteLine("\t\tQuantity: " + detailRow["Quantity"]);
        }
    }
}
 
dataSet.WriteXml(@"C:\tmp\nwinddata.xml");
Console.WriteLine(@"Successfully wrote XML output to file c:\tmp\nwinddatam.xml");
 
thisConnection.Close();
Console.WriteLine("Program finished, press Enter/Return to continue");
Console.ReadLine();
</code>
												</pre>
											</div>
										</div>
									</div>
								</div>

							</div>
						</div>
					</div>

					<div class="title">其他数据提供者</div>
					<div class="content closed">
						<p class="text-strong">Oracle .NET数据提供者</p>
						<p>
							如果使用的是Oracle数据库, 内置Oracle.NET驱动程序是最佳选择, .NET Framework就提供了这个驱动程序, 相关类位于System.Data.OracleClient命名空间中！
						</p>
						<p>Oracle本身也提供了一个.NET数据提供者, 引用为Oracle.DatAccess.Client. 它必须从Oracle中单独下载. </p>
						<p>使用数据库销售商提供的.NET数据提供者, 还是.NET Framework提供的.NET数据提供者, 完全取决于读者自己. 一般销售商的提供者能更多地利用数据库产品的特定功能, 但对于基本或初级使用来说, 它们都不错. 两个提供者都能工作, 读者可以使用自己喜欢的那个.
						</p>	

						<p class="text-strong">OLE DB.NET提供者</p>
						<p>对于不是SQL Server或Oracle的数据源(比如Microsoft Access)而言, 可以使用OLE DB.NET数据提供者, 相关类位于System.Data.OleDb命名空间中！</p>
						<p>许多常见数据库的OLE DB提供者会随Windows一起安装, 例如Microsoft Access.</p>
						<p>Access数据库注意事项</p>
						<p>
							SELECT [First Name], [Last Name] FROM Employees WHERE [Last Name] LIKE 'D*' ORDER BY [First Name] DESC; <br>
							1) SQL语句在Access中应以分号结尾. 但是如果忘记添加分号, 也没有关系, 因为Access会自动添加. <br>
							2) 需要把这些字段放在方括号中, 因为这些字段名称包含空格. <br>
							3)　为了使结果更清晰, 可以按升序排列, 在ORDER BY子句中用ASC替代DESC即可. 实际上不需要这么做, 因为升序是默认的排序方式.
						</p>

						<p class="text-strong">ODBC.NET数据提供者</p>
						<p>
							如果数据源没有内置的或OLE DB提供者, 则可以使用ODBC.NET数据提供者, 因为大多数数据库都提供了ODBC接口. ODBC提供者可以通过下面的using指令来引用:
							using System.Data.Odbc;
						</p>

						<p class="text-strong">其他内置的.NET数据提供者</p>
						<p>
							如果数据库有专用的内置.NET数据提供者, 就可以使用它. 其他许多数据库销售商和第三方公司也提供了内置.NET数据提供者, 选择内置提供者还是使用通用的ODBC提供者取决于程序运行的环境. 如果可移植性的要求高于性能, 就应使用通用的ODBC提供者. 如果性能要求高或者要充分利用某个数据库的功能, 就应使用内置.NET数据提供者.
						</p>

						<p>注: 在每一个.NET数据提供者中定义的对象, 其名称前带有特定提供者的名称. 因此, 用于OLE DB提供者的连接对象就是OleDbConnection, 用于SQL Server .NET提供者的类型就是SqlConnection.</p>
					</div>
				</div>
			</div>

			<div class="title">用户对象</div>
			<div class="content open">
				TBD...
			</div>

			<div class="title">XML & ADO.NET</div>
			<div class="content open">

			</div>
		</div>
    </div>

	<!--ORM - Dapper-->
    <div class="title">ORM - Dapper</div>
    <div class="content closed">        

        <!--Execute a query and map the results to a strongly typed List-->
        <div class="list list-square">
            <div class="title">Execute a query and map the results to a strongly typed List - Query()</div>
            <div class="content closed">
                <pre class="prettyprint linenums lang-cs">
<code>
// 数据库实体类
public class Dog
{
    public int? Age { get; set; }
    public Guid Id { get; set; }
    public string Name { get; set; }
    public float? Weight { get; set; }

    public int IgnoredProperty { get { return 1; } }
}            
            
// 查询
var guid = Guid.NewGuid();
var dog = connection.Query&lt;Dog>("select Age = @Age, Id = @Id", new { Age = (int?)null, Id = guid });

Assert.Equal(1, dog.Count());
Assert.Null(dog.First().Age);
Assert.Equal(1, dog.ElementAt(0).Age);
Assert.Equal(guid, dog.First().Id);
</code>
				</pre>
            </div>

            <!--Execute a query and map it to a list of dynamic objects-->
            <div class="title">Execute a query and map it to a list of dynamic objects - Query()</div>
            <div class="content closed">
                <pre class="prettyprint linenums lang-cs">
<code>
var guid = Guid.NewGuid();
var dog = connection.Query("select Age = @Age, Id = @Id", new { Age = (int?)null, Id = guid });

Assert.Equal(1, dog.Count());
Assert.Null(dog.First().Age);
Assert.Equal(1, dog.ElementAt(0).Age);
Assert.Equal(guid, dog.First().Id);
</code>
				</pre>
            </div>

            <!--Execute a Command that returns no results-->
            <div class="title">Execute a Command that returns no results - Execute()</div>
            <div class="content closed">
                <pre class="prettyprint linenums lang-cs">
<code>
var count = connection.Execute(@"
  set nocount on 
  create table #t(i int) 
  set nocount off 
  insert #t 
  select @a a union all select @b 
  set nocount on 
  drop table #t", new {a=1, b=2 });
Assert.Equal(2, count);
</code>
				</pre>
            </div>

            <!--Execute a Command multiple times-->
            <div class="title">Execute a Command multiple times - Execute()</div>
            <div class="content closed">
                <pre class="prettyprint linenums lang-cs">
<code>
var count = connection.Execute(@"insert MyTable(colA, colB) values (@a, @b)",
    new[] { new { a=1, b=1 }, new { a=2, b=2 }, new { a=3, b=3 } }
  );
Assert.Equal(3, count); // 3 rows inserted: "1,1", "2,2" and "3,3"
</code>
				</pre>
            </div>
        </div>

		<p>
			参考资料: 
			<a href="https://github.com/StackExchange/Dapper">官网</a>, 
			<a href="http://www.cnblogs.com/Sinte-Beuve/p/4231053.html">Dapper的基本使用</a>
		</p>
    </div>

	<!--ORM - Enity Framework-->
    <div class="title">ORM - Entity Framework</div>
    <div class="content closed">
        <a href="https://msdn.microsoft.com/en-us/library/aa937723(v=vs.113).aspx">官方资料</a><br>
        <a href="http://www.cnblogs.com/wujingtao/p/5401113.html">Entity Framework 6快速入门</a>
    </div>

	<div class="title">其他</div>
	<div class="content closed">

	</div>
</div>
{include file="template/footer" /}