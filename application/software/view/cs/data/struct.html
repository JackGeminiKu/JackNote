{include file="template/header" title="C# 结构体" /}
<p> 每个结构都派生于System.ValueType, System.ValueType派生于System.Object. 可以把C#中的结构看作是缩小的类, 只是结构更适合于把一些数据组合起来的场合.</p>

<div class="list list-number">
    <div class="title">定义</div>
    <div class="content open">
		<pre class="prettyprint linenums">
<code>
struct Point                       
{
    public int X;
    public int Y;
}

public struct MyStruct&lt;T1>    // 结构支持泛型
{
    public T1 item1;
}
</code>
		</pre> 
    </div>

	<div class="title">定义变量</div>
    <div class="content open">
		<pre class="prettyprint linenums">
<code>
Point point;                    // 由于结构是值类型, 变量声明的时候会为整个结构分配堆栈中的空间.
Point point = new Point();      // 由于结构是值类型, new运算符并不分配堆中的内存, 而是调用相应的构造函数, 根据传送给它的参数, 初始化所有的字段.
</code>
		</pre> 
    </div>

	<div class="title">常用操作</div>
    <div class="content open">
		<pre class="prettyprint linenums">
<code>
// 赋值: 把point2中所有字段的值, 赋给point1的对应字段, 不需要一个字段一个字段的赋值哦!	
point1 = point2;
// 访问元素	
point.X = 0;
</code>
		</pre> 
    </div>

    <div class="title">结构体 vs 类</div>
    <div class="content open">
		<table class="table table-bordered table-sm w-50">
			<tbody>
				<tr>
					<th>项目</th>
					<th>结构体</th>
					<th>类</th>
				</tr>
				<tr>
					<td>类型</td>
					<td>值类型</td>
					<td>引用类型</td>
				</tr>
				<tr>
					<td>继承</td>
					<td>不支持</td>
					<td>支持</td>
				</tr>
				<tr>
					<td>接口</td>
					<td>支持</td>
					<td>支持</td>
				</tr>
				<tr>
					<td>字段初始化</td>
					<td>不能初始化, 只能在构造函数中赋值</td>
					<td>可以</td>
				</tr>
				<tr>
					<td>默认构造函数</td>
					<td>不允许定义, 编译器会提供</td>
					<td>支持</td>
				</tr>
				<tr>
					<td>性能</td>
					<td>低</td>
					<td>高</td>
				</tr>
			</tbody>
		</table>

    </div>
</div>
{include file="template/footer" /}