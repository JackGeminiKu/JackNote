{include file="template/header" title="C# 类" /}

<div class="list list-number">
    <!--各种类-->
    <div class="title">各种类</div>
    <div class="content open">
        <div class="list list-number">

            <!--普通类-->
            <div class="title">普通类</div>
            <div class="content open">
                <p>
                    [ internal | public ] class 类名 : 基类, 接口1, 接口2... <br> {
                </p>
                <div class="pl-4">

                </div>
                <p>}</p>

                <div class="list list-square">
                    <div class="title">继承 vs 接口</div>
                    <div class="content closed">
                        <p class="text-strong">继承</p>
                        <p>当且仅当两个类之间是"is-a"关系时, 才能考虑使用继承! C#支持单继承!</p>

                        <p>
                            如果子类派生于父类, 那么:<br> 1) 继承: 子类自动继承父类除private外的所有属性, 事件 & 方法; <br> 2) 重写: 子类可以重写继承自父类的属性,事件和方法; <br> 3) 新增: 子类可以添加父类没有的属性, 事件和方法.
                        </p>

                        <p>所有的.NET类最后都派生于Object. 实际上, 如果在定义类时没有指定基类, 编译器就会自动假定这个类派生于Object.</p>

                        <p class="text-strong">接口</p>
                        <p>表示一个类型只继承了函数的签名, 却没有继承任何实现代码.</p>
                        <p>在需要指定该类型具有某些可用的特性时, 最好使用这种类型的继承. 例如, 某些类型可以指定从接口System.IDisposable中派生, 从而提供一种清理资源的方法Dispose(). 由于某种类型清理资源的方式可能与另一种类型完全不同, 所以定义通用的实现代码是没有意义的, 此时就适合使用接口继承.</p>
                        <p>注意: C#不支持多重继承, 但是C#又允许类型派生于多个接口.</p>

                        <p class="text-strong">抽象类&接口比较</p>
                        <p>
                            相同点: <br> 抽象类和接口都包含可以由派生类继承的成员. <br> 接口和抽象类都不能直接实例化, 但可以声明它们的变量, 通过多态性使用它们.
                        </p>
                        <p>
                            不同点: <br> 一个类只能继承一个抽象类, 但是可以实现多个接口等等.. <br> 抽象类可以给出一些成员的实现, 但是接口不能包含成员的实现! <br> 抽象类的抽象成员可以被子类部分实现, 但是接口的成员需要实现类完全实现! <br> 接口成员只能是公共的, 但抽象类的成员没有限制. <br> 接口不能包含字段, 构造函数, 析构函数, 静态成员或常量
                        </p>
                        <p>
                            这说明这两种类型用于完全不同的目的. 抽象类主要用作对象系列的基类, 共享某些主要特性, 例如共同的目的和结构. 接口则主要用于类, 这些类在基础水平上有所不同, 但仍可以完成某些相同的任务. <br> 通俗来说, 抽象类, 本质上是一类; 接口, 只是具有相似的行为.
                        </p>
                        <p>上面是从两者的形态上去区分的, 我觉得还有三点式能帮助我们去区分抽象类和接口的.</p>

                        <p>1) 类是对对象的抽象, 抽象类是对类的抽象, 接口是对行为的抽象. <br> 接口是对类的局部(行为)进行的抽象, 而抽象类是对类整体(字段, 属性, 方法)的抽象. 如果只关注行为抽象, 那么也可以认为接口就是抽象类. 总之, 不论是接口, 抽象类, 类甚至对象, 都是在不同层次, 不同角度进行抽象的结果, 它们的共性就是抽象.
                        </p>

                        <p>2) 如果行为跨越不同类的对象, 可以使用接口; 对于一些相似的类对象, 则用继承抽象类. <br> 比如猫啊狗啊它们其实都是动物, 它们之间有很多相似的地方, 所以我们应该让它们去继承动物这个抽象类, 而飞机, 麻雀, 超人是完全不相关的类, 叮当是动漫角色, 孙悟空是古代神话人物, 这也是不相关的类, 但它们又是有共同点的, 前三个都会飞, 而后两个都会变出东西, 所以此时让它们去实现相同的接口来达到我们的设计目的就很合适了.
                        </p>

                        <p>3) 从设计角度讲, 抽象类是从子类中发现了公共的东西, 泛化出父类, 然后子类继承父类, 而接口是根本不知子类的存在, 方法如何实现还不确认, 预先定义. <br> 这里其实说明的是抽象类和接口设计的思维过程. 回想一下我们今天刚开始讲的时候, 先是有一个Cat类, 然后再有一个Dog类, 观察后发现它们有类似之处, 于是泛化出Animal类, 这也体现了敏捷开发的思想, 通过重构改善既有代码的设计. 事实上, 只有小猫的时候, 你就去设计一个动物类,
                            这就极有可能会成为过度设计了. 所以说抽象类往往都是通过重构得来的, 当然, 如果你事先意识到多种分类的可能, 那么实现就设计出抽象类也是完全可以的. 而接口就完全不是一回事, 比如我们是动物运动会的主办方, 在策划时, 大家就坐在一起考虑需要组织什么样的比赛, 大家商议后, 觉得应该设置如跑得最快, 跳得最高, 飞得最远, 叫得最响, 力气最大等等比赛项目, 而此时, 主办方其实还不太清楚会有什么样的动物来参加运动会, 所有的这些比赛项目都可能是完全不相同的动物在比,
                            它们将如何去实现这些行为也不得而知, 此时, 能做的事就是事先定义这些比赛目的的行为接口.
                        </p>
                    </div>

                    <div class="title">访问修饰符</div>
                    <div class="content closed">
                        <p>
                            private: 当前类中 <br> protected: 当前类 + 派生类 <br> internal: 当前类 + 当前程序集 <br> protected internal: 当前类 + 派生类 + 当前程序集 <br> public 当前类 + 任何地方
                        </p>
                    </div>
                </div>

            </div>

            <div class="title">静态成员 & 静态类</div>
            <div class="content closed">
                <div class="list list-number">
                    <div class="title">类的静态成员</div>
                    <div class="content open">
                        <div class="container-fluid">
                            <div class="row">
                                <div class="col-5">
                                    <pre class="prettyprint linenums">
<code>
public class Automobile
{
    public static int NumberOfWheels = 4;        // 静态字段
    public static int SizeOfGasTank              // 静态属性
    {
        get{ ... }
    }
 
    public static void Drive() { }               // 静态方法
    public static event EventType RunOutOfGas;   // 静态事件

    static SimpleClass()   						// 静态构造函数
    {
        // 静态构造函数只能访问类的静态成员, 不能访问实例成员.
    }
 
    //other non-static fields and properties...
}
</code>
									</pre>

                                </div>
                                <div class="col-6">
                                    <p>静态成员可以理解为是类的成员, 而不是对象的成员! 它们不会随对象状态而变化.</p>

                                    <p class="text-strong">调用静态成员</p>
                                    <p>MyStaticClass.XXX</p>

                                    <p class="text-strong">可访问成员</p>
                                    <p>静态方法只能访问静态成员, 但是可以访问类的构造函数; 而非静态方法则可以访问所有的成员.</p>

                                    <p class="text-strong">静态构造函数</p>
                                    <p>用户不能直接调用静态构造函数, 也不能控制何时执行静态构造函数. 在创建类的第一个实例或引用任何静态成员之前, 程序将自动调用静态构造函数, 且静态构造函数只会调用一次. </p>
                                    <p>所以静态构造函数用于初始化任何静态数据, 或用于执行仅需执行一次的特定操作. 静态构造函数具有如下特点:
                                    </p>
                                    <p>
                                        1) 静态构造函数的典型用途是: 当类使用日志文件时, 将使用这种构造函数向日志文件中写入项. <br> 2) 静态构造函数在为非托管代码创建包装类时也很有用, 此时该构造函数可以调用 LoadLibrary 方法. <br> 3) 如果静态构造函数引发异常, 运行时将不会再次调用该构造函数, 并且在程序运行所在的应用程序域的生存期内, 类型将保持未初始化.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="title">静态类</div>
                    <div class="content open">
                        <div class="container-fluid">
                            <div class="row">
                                <div class="col-5">
                                    <pre class="prettyprint linenums">
<code>
static class CompanyInfo
{
    public static string GetCompanyName()
    {
        return "CompanyName";
    }
}
</code>
									</pre>
                                </div>
                                <div class="col-6">
                                    <p>
                                        类可以声明为静态, 以表明它只能包含静态成员. 静态类的主要特点如下：<br> 1) 只能包含静态成员. <br> 2) 不能被实例化, 所以不能包含实例构造函数, 但可声明静态构造函数以分配初始值或设置某个静态状态. <br> 3) 不能被继承.
                                    </p>
                                    <p>
                                        静态类一般用于实现函数库, 例如System命名空间中的Math类的方法。此外，静态类能够使您的实现更简单、迅速，因为您不必创建对象就能调用其方法.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="title">抽象类</div>
            <div class="content closed">
                <p>抽象类不能实例化, 抽象类的用途是提供多个派生类可共享的基类的公共定义.</p>
                <pre class="prettyprint linenums">
<code>
abstract class A
{
    // 非抽象部分: 抽象类可以有非抽象成员
    public A()                                                   // 构造函数
    {
        // (1) 用于为继承自它的子类使用
        // (2) 用于初始化抽象类的成员
        // (3) 而且抽象类可以使用工厂模式, 参考XmlWriter.Create()
    }
 
    ~A() {  }                                                    // 析构函数
 
    public void DoActualWork() { }                               // 普通函数
　
    public int MyProperty { get; set; }                          // 普通属性
	
    // 抽象部分: 抽象成员只能能存在于抽象类中, 并且派生类一定要实现这些抽象成员
    public abstract void DoAbstractWork();                       // 抽象方法
 
    public abstract int MyAbstractProperty { get; set; }         // 抽象属性
}
</code>
				</pre>


                <p class="text-strong">抽象类 vs 接口</p>
                <p>使用抽象类, 可以共享代码, 但是一个类只能继承自一个基类; 而接口虽然不能实现代共享代码, 却可以实现多个!</p>
            </div>

            <div class="title">密封成员 & 密封类</div>
            <div class="content closed">
                <p>密封类不能被继承</p>
                <pre class="prettyprint linenums">
<code>
public sealed class Animal
{
}
</code>
				</pre>

                <p>密封成员不能被重写</p>
                <pre class="prettyprint linenums">
<code>
public class Animal 
{
    public sealed void Shout
}
</code>
				</pre>

                <p>在对基类的虚成员进行重写的派生类上, 方法、字段、属性或事件可以声明为为selaed。在用于以后的派生类时，这将取消成员的虚效果.</p>
                <pre class="prettyprint linenums">
<code>
public class D : C
{
    public sealed override void DoWork() { }
}
</code>
				</pre>

                <p class="text-danger">
                    把类或方法标记为sealed时, 最可能的情况是: 如果要对库, 类或自己编写的其他类进行操作, 则重写某些功能会导致错误. 也可以因商业原因把类或方法标记为sealed, 以防第三方以违反注册协议的方式扩展该类. <br> 一般情况下, 在把类或方法标记为sealed时要小心, 因为这么做会严重限制它的使用. 即使不希望它能继承一个类或重写类的某个成员, 仍有可能在将来的某个时刻, 有人会遇到我们没有预料到的情形.
                </p>
            </div>

            <div class="title">嵌套类</div>
            <div class="content closed">
                <p>除了在命名空间中定义类之外, 还可以在其他类中定义这些类 - 这种类称为嵌套类.</p>
                <p>
                    1) 可以为嵌套类指定private访问修饰符，只有嵌套类才可以这样做。<br> 2) 嵌套类要想访问包容类的实例，一个办法是显式传递包容类的实例，比如通过一个构造器或方法参数。 <br> 3) 嵌套类能访问包容类的任何成员，甚至是私有成员。但包容类不能访问嵌套类的私有成员。<br> 4) 嵌套类一般很少用。除此之外，要警惕public 嵌套类，它们意味着不良的编码风格，有可能造成混淆和难以发现。
                </p>

                <pre class="prettyprint linenums">
<code>
public class MyClass
{
    public event EventHandler MyEvent;
 
    public class MyNestedClass
    {
        public int nestedClassField;
　
        public void TriggerOuterEvent()
        {
            MyClass myClass = new MyClass();
            myClass.MyEvent(myClass, EventArgs.Empty);        // 嵌套类可以触发外部类的事件(一般来说其他类的事件只能被订阅), 嵌套类可以访问外围类中的所有成员, 包括Private的!
        }
    }
}
</code>
				</pre>
            </div>

            <div class="title">泛型类 & 泛型成员</div>
            <div class="content closed">
                <div class="list list-number">
                    <div class="title">什么是泛型</div>
                    <div class="content open">
                        <p>
                            泛型把类或方法的类型的确定, 推迟到实例化该类或方法的时候 ，也就是说刚开始定义时不指定类型，等到要使用（实例化）时再指定类型. 泛型可以用于类、方法、委托、事件等. 使用泛型的好处是: <br> 1) 设计更加通用的类型; <br> 2) 避免容器操作中的装箱和拆箱操作！
                        </p>

                        <p>但是由于"泛型把类或方法的类型的确定, 推迟到实例化类或方法的时候", 所以泛型支持的操作比较有限!</p>
                    </div>

                    <div class="title">定义泛型</div>
                    <div class="content open">
                        <p class="text-strong">定义泛型类</p>
                        <pre class="prettyprint linenums">
<code>
class MyGenericClass&lt;T>
{
    // 可以在类中使用泛型T, 就像使用普通数据类型一样
}
</code>
						</pre>

                        <p class="text-strong">定义泛型方法</p>
                        <pre class="prettyprint linenums">
<code>
public T Get&lt;T>(string property, T defaultValue)
{
    // 可以在方法中使用泛型T, 就像使用普通数据类型一样
}
</code>
						</pre>

                        <p class="text-strong">当父类是泛型时</p>
                        <pre class="prettyprint linenums">
<code>
// 子类不是泛型类: 父类中的T必须显式提供.
public class Cards : List&lt;Card>
{ }

// 子类也是泛型类: T在父类和子类中的约束不能冲突
class SuperFarm&lt;T> : Farm&lt;T> where T : SuperCow
{ }
</code>
						</pre>

                        <p class="text-strong">约束类型</p>
                        <table class="table table-bordered table-sm w-50">
                            <tbody>
                                <tr>
                                    <td>约束类型</td>
                                    <td>解释</td>
                                </tr>
                                <tr>
                                    <td>struct / class</td>
                                    <td>类型必须是值类型/引用类型</td>
                                </tr>
                                <tr>
                                    <td>base class / interface</td>
                                    <td>类型必须继承自指定类 / 实现了指定接口, 不能指定多个类或接口</td>
                                </tr>
                                <tr>
                                    <td>new()</td>
                                    <td>类型必须有一个公共的无参构造函数</td>
                                </tr>
                            </tbody>
                        </table>
                        <pre class="prettyprint linenums">
<code>
class MyGenericClass&lt;T> where T: 约束
{ }

class MyGenericClass&tl;T1,T2> where T1: 约束1 where T2: 约束2    // 可以使用多个where语句
{ }

class MyGenericClass&lt;T> where T: 约束1, 约束2    // 多个约束之间用逗号分隔
{ }

class MyGenericClass&lt;T1,T2> where T2: T1    // 裸类型约束
{ }
</code>
						</pre>
                    </div>

                    <div class="title">default关键字</div>
                    <div class="content open">
                        <p>
                            在泛型类和泛型方法中产生的一个问题是，在预先未知以下情况时，如何将默认值分配给参数化类型T? 解决方案是使用default关键字: <br> 1) 对于引用类型会返回空(null); <br> 2) 对于数值类型会返回零; <br> 3) 对于结构体类型，此关键字将返回初始化为零或null的每个结构成员，具体取决于这些成员是值类型还是引用类型.
                        </p>

                        <pre class="prettyprint linenums">
<code>
T temp = default(T);
</code>
						</pre>
                    </div>
                </div>
            </div>

            <div class="title">部分类 & 部分方法</div>
            <div class="content closed">
                <p>partial关键字允许把类, 结构或接口放在多个文件中. 一般情况下, 一个类存储在单个文件中. 但有时, 多个开发人员需要访问同一个类, 或者某种类型的代码生成器生成了一个类的某部分, 所以把类放在多个文件中是有益的. 在把部分类编译到类型中时, 会合并属性, XML注释, 接口, 一般类型的参数属性和成员.</p>

                <pre class="prettyprint linenums">
<code>
// BigClassPart1.cs
partial class TheBigClass
{
    public void MethodOne()
    { }
}
 
// BigClassPart2.cs
partial class TheBigClass
{
    public void MethodTwo()
    { }
}
</code>
				</pre>
                <p class="text-danger">如果声明类时使用了下面的关键字, 这些关键字将应用于同一个类的所有部分: private, protected, internal, public, abstract, sealed, 基类, new, 一般约束.</p>
            </div>
        </div>
    </div>

    <!--高级功能-->
    <div class="title">高级功能</div>
    <div class="content open">
        <div class="list list-number">
            <div class="title">对象复制</div>
            <div class="content closed">
                <p class="text-strong">1. MemberwiseClone</p>
                <p>调用受保护的方法: System.Object.MemberwiseClone(), 只能实现浅复制.</p>
                <p class="text-strong">2. ICloneable</p>
                <p>可根据需要实现深/浅复制.</p>
            </div>

            <div class="title">对象比较</div>
            <div class="content closed">
                <div class="list list-number">
                    <div class="title">给对象添加比较功能</div>
                    <div class="content open">
                        <p class="text-strong">IComparable</p>
                        <p>int CompareTo(Object obj)</p>
                        <p class="text-strong">IComparer</p>
                        <p>int Compare(Object x, Object y)</p>
                    </div>

                    <div class="title">比较类</div>
                    <div class="content open">
                        <p class="text-strong">1. Comparer</p>
                        <p>
                            Comparer.Default: 比较过程使用当前线程的 Thread.CurrentCulture 来确定排序顺序和大小写规则. <br> Comparer.DefaultInvariant: 比较过程使用 CultureInfo.InvariantCulture 确定排序顺序和大小写规则
                        </p>
                        <p>
                            使用这个类的注意事项: <br> 1) 传送给Comparer.Compare()的对象, 必须支持IComparable. <br> 2) 允许使用null值, 它表示"小于"其他对象. <br> 3) 字符串根据当前文化来处理. 要根据不同的文化(或语言)处理字符串, Comparer类必须使用其构造函数进行实例化, 以便传送指定文化的System.Globalization.CultureInfo对象. <br> 4) 字符串在处理是要区分大小写.
                            如果要以不区分大小写的方式来处理它们, 就需要使用下面的类 - CaseInsensitiveComparer, 该类以相同的方式工作.
                        </p>

                        <p class="text-strong">2. CaseInsensitiveComparer</p>
                    </div>
                </div>

            </div>

            <div class="title">添加迭代器功能</div>
            <div class="content closed">
                <div class="list list-number">
                    <div class="title">默认迭代器</div>
                    <div class="content open">
                        <p>
                            ① 实现IEnumerable接口 ( 只有一个成员IEnumerator GetEnumerator() ) <br> ② 定义一个方法, 原型为: public IEnumerator GetEnumerator()
                        </p>
                        <pre class="prettyprint linenums">
<code>
// 添加迭代功能
public IEnumerator GetEnumerator()
{
    for ( int i = 0; i < 10; ++i )
        yield return i;
}

// 使用迭代器
foreach( int i in enumerableObject ){
    Console.WriteLine(i);
}
</code>
						</pre>
                    </div>

                    <div class="title">命名迭代器</div>
                    <div class="content open">
                        <p>在类中定义一个方法: 只需要返回IEnumerable类型即可</p>
                        <pre class="prettyprint linenums">
<code>
// 添加迭代器功能	
public IEnumerable Reverse()
{
    for ( int i = 9; i >=0; --i )
         yield return i;
}

// 使用命名迭代器
foreach( int i in enumerableObject.Reverse() ){
    Console.WriteLine(i);
}
</code>
						</pre>
                    </div>
                </div>

            </div>

            <div class="title">函数调用: 同步 vs 异步</div>
            <div class="content closed">
                <div class="list list-number">
                    <div class="title">异步调用范例</div>
                    <div class="content open">
                        <div class="container-fluid">
                            <div class="row">
                                <div class="col-7">
                                    <pre class="prettyprint linenums">
<code>
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("[{0}] [{1:D2}]: {2}", DateTime.Now.ToString("HH:mm:ss"), Thread.CurrentThread.ManagedThreadId, "main");
        for (int i = 0; i < 3; i++) {
            Func&lt;int, int, int> func = new Func&tl;int, int, int>(Add);
            func.BeginInvoke(i, i, AddCallback, null);  // 异步调用
        }

        Console.Read();
    }

    static int Add(int a, int b)
    {
        Console.WriteLine("[{0}] [{1:D2}]: {2} + {3}",
            DateTime.Now.ToString("HH:mm:ss"), Thread.CurrentThread.ManagedThreadId, a, b);
        Thread.Sleep(3000);
        return a + b;
    }

    static void AddCallback(IAsyncResult result)
    {
        Thread.Sleep(3000);
        Func&lt;int, int, int> func = (Func&lt;int, int, int>)((AsyncResult)result).AsyncDelegate;
        Console.WriteLine("[{0}] [{1:D2}]: result = {2}", DateTime.Now.ToString("HH:mm:ss"),
            Thread.CurrentThread.ManagedThreadId, func.EndInvoke(result));
    }
}
</code>
									</pre>
                                </div>
                                <div class="col-5">
                                    <p>输出结果</p>
                                    <pre class="prettyprint linenums">
<code>
[20:08:41] [09]: main
[20:08:41] [10]: 0 + 0
[20:08:41] [13]: 1 + 1
[20:08:41] [14]: 2 + 2
[20:08:47] [10]: result = 0
[20:08:47] [13]: result = 2
[20:08:47] [14]: result = 4
</code>
									</pre>
                                    <p>
                                        说明: 异步调用时, 函数在另外一个线程中执行, 并且回调函数也在这个新线程中执行!
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="title">XXX</div>
                    <div class="content open">

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<hr>
<div class="list list-none">
    <div class="title">参考资料...</div>
    <div class="content open">
        <a href="https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2008/ms182357(v=vs.90)">重载等号运算符时重写 Equals 方法</a>
    </div>
</div>

{include file="template/footer" /}