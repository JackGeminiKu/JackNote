{include file="template/header" title="C# 类" /}

<div class="list list-number">
	<!--各种类-->
	<div class="title">各种类</div>
	<div class="content open">
		<div class="list list-number">

			<!--普通类-->
			<div class="title">普通类</div>
			<div class="content open">
				<p>[ internal | public ] class 类名 : 基类, 接口1, 接口2...<br></p>
				<p>{</p>
				<div class="pl-4">
					<div class="list list-square">
						<!--数据-->
						<div class="title">数据</div>
						<div class="content open">
							<div class="list list-square">
								<!--常量-->
								<div class="title">常量</div>
								<div class="content closed">
									<pre class="prettyprint linenums lang-cs">
<code>
const double PI = 3.14;    // const型: 只能由初始化语句赋值, 在静态&非静态的类成员中均可使用.
readonly double PI = 3.14;    // readonly型: 可以由初始化语句赋值, 也可以在构造函数中赋值. 加上static后不能混用.
</code>
									</pre>

								</div>

								<!--字段-->
								<div class="title">字段</div>
								<div class="content closed">
									<pre class="prettyprint linenums">
<code>
double Weight [= 60];	// 字段是与类相关的变量. 可以初始化
</code>
									</pre>
									<p>注意: 客户端使用属性和字段的语法是相同的, 但是一般情况下, 最好提供属性. 因为这样可以更好的控制整个过程(比如判断赋的值是否非法), 这个不会影响使用对象实例的代码.</p>
								</div>

								<!--属性-->
								<div class="title">属性</div>
								<div class="content closed">
									<p>属性是一个方法或方法对, 在客户端看来, 它们是一个字段, 但是属性同字段相比, 可以做更多的控制, 所以属性要优于字段.</p>
									<pre class="prettyprint linenums">
<code>
string foreName;

string ForeName
{
    get { return foreName; }	// 访问器可以有自己的可访问性, 但是不能超过属性的可访问性. 
    set				
    {
        if (value.Length > 20) {	// value引用用户提供的属性值, 类型与属性相同.
            // code here to take error recovery action
        } else {
            foreName = value;
        }
    }
}
</code>
									</pre>
									<p class="text-danger"> 注意: 1) 可以定义只读或只写属性. 2) C#不支持属性带参数.</p>

									<p class="text-strong">自动属性（Since .NET 3.5)</p>
									<pre class="prettyprint linenums">
<code>
string PetName { get; set; }  //right
string PetName { get; }  //wrong，必须get set同时，才可为自动的属性；
</code>
									</pre>
								</div>
							</div>
						</div>

						<!--操作-->
						<div class="title">操作</div>
						<div class="content open">
							<div class="list list-square">
								<!--构造函数-->
								<div class="title">构造函数(不能继承)</div>
								<div class="content closed">
									<pre class="prettyprint linenums">
<code>
访问级别 Program ( 形参 )     
{                         
    // 构造函数是用来实例化对象的
    // 构造函数同类同名(支持重载), 用new关键字来调用.
}
</code>
									</pre>

									<p class="text-strong">默认构造函数</p>
									<p>
										如果没有提供任何构造函数, 编译器会自动创建一个默认的构造函数(没有形参的构造函数). <br>
										这是一个非常基本的构造函数, 它只能把所有的成员字段初始化为标准的默认值(例如, 引用类型为null, 数字数据类型为0, bool为false). 这个默认构造函数是public的.
									</p>

									<p class="text-strong">构造函数调用顺序</p>
									<p>调用构造函数之前: 先给字段初始化(如果字段有初始化), 然后调用父类的构造函数.</p>

									<p>
										1) 如果使用base关键字指定了父类的构造函数, 就调用这个构造函数; 否则, 调用父类的默认构造函数! <br>
										2) 也可以用this关键字指定调用本类的其他构造函数!
									</p>

									<p class="text-danger">注意: 父类还有自己的父类哦.</p>
								</div>

								<!--析构函数-->
								<div class="title">析构函数(不能继承)</div>
								<div class="content closed">
									<pre class="prettyprint linenums">
<code>
~类名()
{
    // 我是析构函数!
}
</code>
									</pre>
									<p class="text-strong">默认析构函数 vs 自定义析构函数</p>
									<p>
										析构函数只有一个. 一般情况下, 不需要提供析构函数, 而是由默认的析构函数执行操作. <br>
										但是, 如果在删除对象实例前, 需要完成一些重要的操作, 就应提供特定的析构函数.
									</p>

									<p class="text-strong">析构函数调用时间</p>
									<p>我们无法控制何时调用析构函数, 因为什么时候调用是由GC决定的, 所以我们不应该依赖析构函数来释放对象实例所使用的资源.</p>

									<p class="text-strong">析构函数调用顺序</p>
									<p>析构函数调用顺序同构造函数调用顺序相反, 即先调用子类的析构函数, 再调用父类的析构函数.</p>
								</div>

								<!--方法-->
								<div class="title">方法</div>
								<div class="content closed">
									<div class="list list-number">
										<div class="title">定义</div>
										<div class="content closed">
											<pre class="prettyprint linenums">
<code>
return_type MethodName([parameters])
{
    // 注意: 在VB, C和C++中,可以定义与类完全不相关的全局函数, 但在C#中不能这样做. 在C#中, 每个函数都必须定义在类或者结构中.
}
</code>
											</pre>

											<div class="list list-square">
												<div class="title">参数传值方式</div>
												<div class="content open">
													<div class="container-fluid">
														<div class="row">
															<div class="col-4">
																<p class="text-strong">默认传参方式: 传值 </p>
																<p>
																	在C#中, 函数参数默认是传值的: <br>
																	1) 值 类 型: 拷贝的是变量的值, 所以实和形参是两个变量! <br>
																	2) 引用类型: 拷贝的是变量的地址, 所以实参和形参指向同一个对象!. </p>
																<p>注意: 默认方式下, 对于引用类型, 在函数内重新赋值, 将使形参指向新的对象. </p>
															</div>
															<div class="col-4">
																<p class="text-strong">强制传引用: out/ref </p>

																<p>
																	不管形参是值类型, 还是引用类型, 使用out/ref关键字, 可以把实参和形参看成是同一个变量! <br>
																	out: 方法返回前, 形参必须赋值;ref: 调用方法时, 实参必须先赋值.
																</p>
															</div>
														</div>
													</div>

												</div>

												<div class="title">可变参数(参数数组)</div>
												<div class="content open">
													<pre class="prettyprint linenums">
<code>
params int[ ] vals    // 参数数组, 必须是最后一个参数, 调用方式: ①数组格式: intArray ②分开格式: int1, int2, int3
</code>
													</pre>
												</div>

												<div class="title">默认参数</div>
												<div class="content open">
													<p class="text-danger">不支持!</p>
												</div>

											</div>
										</div>

										<div class="title">调用</div>
										<div class="content closed">
											<pre class="prettyprint linenums">
<code>
myInstance.Method();	// 实例方法
MyClass.Method();	// 静态方法
</code>
											</pre>
										</div>


										<div class="title">重载</div>
										<div class="content closed">
											<p>
												C#支持方法重载, 对于重载方法: <br>
												1) 两个方法不能仅在返回类型上有区别. <br>
												2) 两个方法不能仅根据参数声明为ref还是out来区分.
											</p>
										</div>

										<div class="title">递归</div>
										<div class="content closed">
											<pre class="prettyprint linenums">
<code>
 private void RecurseXmlDocument(XmlNode root, int indent)
{
    // Make sure we don't do anything if the root is null.
    if (root == null)
        return;
 
    if (root is XmlElement) // Root is an XmlElement type
    {
        // first, print the name
        listBoxXmlNodes.Items.Add(root.Name.PadLeft(root.Name.Length + indent));
 
        // The check if there are child nodes and if there are, call this
        // method again to print them.
        if (root.HasChildNodes)
            RecurseXmlDocument(root.FirstChild, indent + 2);
 
        // Finally check to see if there are any siblings and if there are
        // call this method again to have them printed.
        if (root.NextSibling != null)
            RecurseXmlDocument(root.NextSibling, indent);
    } else if (root is XmlText) {
        // Print the text.
        string text = ((XmlText)root).Value;
        listBoxXmlNodes.Items.Add(text.PadLeft(text.Length + indent));
    }
}
</code>
											</pre>	
										</div>

										<div class="title">扩展</div>
										<div class="content closed">
											<pre class="prettyprint linenums">
<code>
public static class StringExtension	// 静态类
{
    public static void Foo(this string s)	// this后是要扩展的类
    {
        Console.WriteLine("Foo invoked for {0}",s);
    }
}
</code>
											</pre>	
										</div>

										<div class="title">父类方法</div>
										<div class="content closed">
											<div class="list list-number">
												<div class="title">如何调用父类的方法</div>
												<div class="content open">
													<p>使用base关键字</p>
												</div>

												<div class="title">sealed, abstract, virtual & new</div>
												<div class="content open">
													<p>
														密封方法: sealed方法, 派生类不能重!. <br>
														抽象方法: abstract方法, 派生类中重写! <br>
														隐藏方法: 无论父类的方法是否是virtual, 都可以new关键字强行重写函数. <br>
														虚方法: virtual方法, 派生于可以重写, 也可以不重写! 
													</p>
												</div>

												<div class="title">多态 & 隐藏</div>
												<div class="content open">
													<p>
														当父类引用指向一个子类对象时: <br>
														1) 如果调用的方法被子类重写类，则调用子类方法 --- 此为多态. <br>
														2) 否则, 则调用基类的方法 --- 此为隐藏.
													</p>	
												</div>
											</div>	
										</div>

										<div class="title">入口函数</div>
										<div class="content closed">
											<pre class="prettyprint linenums">
<code>
// 不带参数
static void Main()
{
}

// 带参数
static void Main(string[] args)
{
}
</code>
											</pre>
											<p>
												注意: <br>
												命令行参数args[]: 每个参数需要用空格隔开, 如果参数包含空格, 需要用双引号把参数括起来. <br>
												可以在Visual Studio中定义命令行参数, 以便于调试. 只需在Solution Explorer | Properties | Debug | Command line arguments中输入即可.
											</p>
										</div>

										<div class="title">如何调用外部dll中的非托管函数?</div>
										<div class="content closed">
											<p>
												[DllImport("DLL文件名")] <br>
												修饰符 extern 返回变量类型 方法名称 （参数列表）
											</p>
											<p>其中：访问修饰符, 除了abstract以外在声明方法时可以使用的修饰符.</p>

											<p>
												注意： <br>
												1) 需要在程序声明中使用System.Runtime.InteropServices命名空间. <br>
												2) DLL文件必须位于程序当前目录, 或系统定义的查询路径中（即：系统环境变量中Path所设置的路径）. <br>
												3) 返回变量类型、方法名称、参数列表一定要与DLL文件中的定义相一致. 
											</p>

											<p>详见<a href="http://www.cnblogs.com/gaoweipeng/archive/2009/04/05/1429704.html">C#程序实现动态调用非托管的DLL文件</a></p>
										</div>

										<div class="title">如何与函数交换数据?</div>
										<div class="content closed">
											<p>从优到劣质: ①返回值    ②形参    ③全局变量</p>
										</div>
									</div>
								</div>

								<!--运算符-->
								<div class="title">运算符</div>
								<div class="content closed">
									<div class="list list-number">
										<div class="title">运算符重载</div>
										<div class="content closed">
											<p>虽然使用方法也可以达到同样的功能, 但是在许多情况下, 重载运算符可以生产可读性更高, 更直观的代码.</p>
											<div class="list list-square">
												<div class="title">哪些运算符可以重载?</div>
												<div class="content closed">
													<p>并不是所有的运算符都可以重载, 可以重载的运算符如下表所示:</p>
													<table class="table table-bordered table-sm">
														<tbody>
															<tr>
																<td>类型</td>
																<td>运算符</td>
																<td>限制</td>
															</tr>
															<tr>
																<td>二元算术</td>
																<td>+, -, *, /, %</td>
																<td></td>
															</tr>
															<tr>
																<td>一元算术</td>
																<td>+, -, ++, --</td>
																<td></td>
															</tr>
															<tr>
																<td>二元按位</td>
																<td>&, |, ^, <<, >></td>
																<td></td>
															</tr>
															<tr>
																<td>一元按位</td>
																<td>!, ~, true, false</td>
																<td>true和false必须成对重载</td>
															</tr>
															<tr>
																<td>比较运算</td>
																<td>==, !=, >, >=, <, <=</td>
																<td>必须成对重载</td>
															</tr>
															<tr>
																<td>赋值运算</td>
																<td>+=, -=, *=, /=, %=, >>=, <<=, &=, |=, ^=</td>
																<td>C#不允许重载=运算符, 但如果重载+元算符, 编译器就会自动使用+运算符的重载来执行+=运算符的操作</td>
															</tr>
															<tr>
																<td>索引运算符</td>
																<td>[]</td>
																<td>不能直接重载索引运算符</td>
															</tr>
															<tr>
																<td>数据类型转换</td>
																<td>()</td>
																<td>不能直接重载, 用户定义的数据类型转换允许定义定制的数据类型转换</td>
															</tr>
														</tbody>
													</table>
												</div>

												<div class="title">重载实例</div>
												<div class="content closed">
													<pre class="prettyprint linenums">
<code>
// 重载加法
 public class AddClass1
{
    public int Value;
 
    public static AddClass1 operator +(AddClass1 op1, AddClass1 op2)
    {
        AddClass1 result = new AddClass1();
        result.Value = op1.Value + op2.Value;
        return result;
    }
}

// 重载隐式转换: 如果知道无论在源变量中存储什么值, 数据类型转换总是安全的, 就可以把它定义为隐式转换
 public class ConvClass1
{
    public int Value;
 
    // 重载隐士转换, 可定义多个隐式转换, 具有不同的返回值类型
    public static implicit operator ConvClass2(ConvClass1 op1)
    {
        ConvClass2 result = new ConvClass2();
        result.val = op1.Value;
        return result;
    }
}
 
ConvClass1 op1 = new ConvClass1();
op1.Value = 3;
ConvClass2 op2 = op1;    // 这里会执行隐式转换操作

// 重载显示转换: 如果某些数值可能会出错, 例如丢失数据或抛出异常, 就应把数据类型转换定义为显示转换
 public class ConvClass2
{
    public double val;
 
    // 重载显示转换, 可定义多个显示转换, 具有不同的返回值类型
    public static explicit operator ConvClass1(ConvClass2 op1)
    {
        ConvClass1 result = new ConvClass1();
        checked { result.Value = (int)op1.val; };
        return result;
    }
}
　
ConvClass2 op1 = new ConvClass2();
op1.Value = 3e15;
ConvClass1 op2 = (ConvClass1)op1;    // 这里会执行显示转换操作
</code>
													</pre>
												</div>

												<div class="title">比较运算符重载</div>
												<div class="content closed">
													<p> 

														C#要求成对重载比较运算符. 如果重载了==, 也必须重载!=, 否则会产生编译错误. 另外, 比较运算符必须返回bool类型的值. </p>
													<p>
														注意, 在重载==和!=时, 还因该重载从Object中继承的Equals()和GetHashCode()方法, 否则会产生一个编译警告. 原因是Equals()方法应执行与==运算符相同的相等逻辑. 另外, 不要通过调用Object中继承的Equals()方法的实例版本, 来重载比较运算符, 如果这么做, 在objA是null时计算(objA == objB), 这会产生一个异常, 因为.NET运行库会视图计算null.Equals(objB). 
													</P>
												</div>
											</div>	
										</div>
									</div>
								</div>

								<!--索引器-->
								<div class="title">索引器</div>
								<div class="content closed">
									<pre class="prettyprint linenums">
<code>
public string this[int index]    // 参数&返回值的类型不规定, 而且参数可以有多个!
{
    get { ... }    // 可以是只读或者只写
    set { ... }
}
</code>
									</pre>
								</div>

								<!--事件-->
								<div class="title">事件</div>
								<div class="content closed">

									<div class="container-fluid">
										<div class="row">
											<div class="col-6">
												<pre class="prettyprint linenums">
<code>
class Program
{
    static void Main(string[] args)
    {
        Dog dog = new Dog();
        Host host = new Host(dog);
        AlarmEventArgs alarmEventArgs;
 
        Console.WriteLine("Program is running...");
        Console.WriteLine("Someone is coming...");
 
        alarmEventArgs = new AlarmEventArgs(3);
        dog.OnAlarm(alarmEventArgs);	// 触发事件
 
        Console.Read();
    }
}
　
// ① 定义事件参数
class AlarmEventArgs : EventArgs
{
    public int numberOfThief;
    public AlarmEventArgs(int n)
    {
        numberOfThief = n;
    }
}
 
// ② 事件的发起人
class Dog
{
    public event EventHandler&lt;AlarmEventArgs> Alarm;	// 声明事件
 
    public void OnAlarm(AlarmEventArgs e)	// 定义事件触发函数
    {
        if (this.Alarm != null) {
            Console.WriteLine("The dog is Wangwang...");
            this.Alarm(this, e);
        }
    }
}
　
// ③ 事件的订阅者
class Host
{
    public Host(Dog dog)
    {
        dog.Alarm += new EventHandler&lt;AlarmEventArgs>(HostHandleEvent);	// 添加事件处理程序
    }
 
    public void HostHandleEvent(Object sender, AlarmEventArgs e)	// 定义事件处理函数
    {
        Console.WriteLine("Host caught the thief! The sum is " + e.numberOfThief);
    }
}
</code>
												</pre>	
											</div>
											<div class="col-6">
												<div class="list list-square">
													<div class="title">事件参数</div>
													<div class="content open">
														<p>所有基于EventArgs的类都负责在事件发出者和事件订阅者之间来回传送事件的信息.</p>
														<p>在大多数情况下, EventArgs类中使用的信息都被事件处理程序中的事件订阅者对象使用, 但是, 有时事件处理程序可以把信息添加到EventArgs类中, 使之可用于事件发出者对象.</p>
														<p>而且如果有其他的对象也处理这个事件, 它们就会看到同一个EventArgs对象.</p>
													</div>

													<div class="title">事件返回类型</div>
													<div class="content open">
														<p>注意: 可以为事件提供返回类型, 但这会出问题, 这是因为引发给定的事件, 可能会调用好几个事件处理程序. 如果这些处理程序都返回一个值, 那么我们该使用哪个返回值?</p>
														<p>系统处理这个问题的方式是, 只允许访问由事件处理程序最后返回的那个值, 也就是最后一个订阅该事件的处理程序返回的值.</p>
														<p>这个功能在某些情况下是有用的, 但最好不要使用它们. 推荐使用void类型的事件处理程序, 且避免使用out类型的参数.</p>
													</div>

													<div class="title">多引用</div>
													<div class="content open">
														<p>当一个对象发生某个事件时, 如果有多个引用变量指向该对象, 则多个引用变量都将接到该事件. ( 实际代码是这个样子的, 但是没有书面资料这么说)</p>
													</div>

													<div class="title">事件访问器</div>
													<div class="content open">
														<pre class="prettyprint linenums">
<code>
public class Dog
{
    // 声明一个delegate
    private EventHandler _barked = null;

    //激发事件
    public void Bark()
    {
        if (_barked != null) {
            _barked(null, null);
        }
    }

    //声明事件: 使用访问器
    public event EventHandler Barked
    {
        add
        {
            if (value != null) { _barked += value; };
        }
        remove
        {
            if (value == _barked) { _barked -= null; }
        }
    }
}
</code>
														</pre>
													</div>
													<div class="title">局部变量&事件处理</div>
													<div class="content closed">
														<pre class="prettyprint linenums">
<code>
MyClass pClass = new MyClass();
pClass.MyEvent += MyFunction;
pClass = null;
</code>
														</pre>
														<p>For the specific question "Will pClass be garbage collected": the event subscription has no effect on the collection of pClass (as the publisher).</p>

														<p>For GC in general (in particular, the target): it depends whether MyFunction is static or instance-based.</p>

														<p>A delegate (such as an event subscription) to an instance method includes a reference to the instance. So yes, an event subscription will prevent GC. However, as soon as the object publishing the event (pClass above) is eligible for collection, this ceases to be a problem.</p>

														<p>Note that this is one-way; i.e. if we have:</p>

														<p>publisher.SomeEvent += target.SomeHandler;</p>

														<p>then "publisher" will keep "target" alive, but "target" will not keep "publisher" alive.</p>

														<p>So no: if pClass is going to be collected anyway, there is no need to unsubscribe the listeners. However, if pClass was long-lived (longer than the instance with MyFunction), then pClass could keep that instance alive, so it would be necessary to unsubscribe if you want the target to be collected.</p>

														<p>Static events, however, for this reason, are very dangerous when used with instance-based handlers.</p>
													</div>
												</div>
											</div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
				<p>}</p>

				<div class="list list-square">
					<div class="title">继承 vs 接口</div>
					<div class="content closed">
						<p class="text-strong">继承</p>
						<p>
							如果子类派生于父类, 那么:<br>
							1) 子类自动继承父类除private外的所有属性, 事件 & 方法; <br> 
							2) 子类可以重写继承自父类的属性,事件和方法; <br>
							3) 子类可以添加父类没有的属性, 事件和方法.
						</p>

						<p>当且仅当两个类之间是"is-a"关系时, 才能考虑使用继承!</p>

						<p>所有的.NET类都派生于System.Object. 实际上, 如果在定义类时没有指定基类, 编译器就会自动假定这个类派生于Object.</p>

						<p class="text-strong">接口</p>
						<p>表示一个类型只继承了函数的签名, 却没有继承任何实现代码.</p>
						<p>在需要指定该类型具有某些可用的特性时, 最好使用这种类型的继承. 例如, 某些类型可以指定从接口System.IDisposable中派生, 从而提供一种清理资源的方法Dispose(). 由于某种类型清理资源的方式可能与另一种类型完全不同, 所以定义通用的实现代码是没有意义的, 此时就适合使用接口继承.</p>
						<p>注意: C#不支持多重继承, 但是C#又允许类型派生于多个接口.</p>
					</div>

					<div class="title">访问修饰符</div>
					<div class="content closed">
						<p>
							private: 当前类中 <br>
							protected: 当前类 + 派生类 <br>
							internal: 当前类 + 当前程序集 <br>
							protected internal: 当前类 + 派生类 + 当前程序集 <br>
							public 	当前类 + 任何地方
						</p>
					</div>
				</div>

			</div>

			<div class="title">嵌套类</div>
			<div class="content open">
TBD...
			</div>

			<div class="title">静态成员&静态类</div>
			<div class="content open"></div>

			<div class="title">抽象成员&抽象类</div>
			<div class="content open"></div>

			<div class="title">密封成员&密封类</div>
			<div class="content open">
			</div>

			<div class="title">密封成员&密封类</div>
			<div class="content open"></div>

			<div class="title">部分类</div>
			<div class="content closed">
				<pre class="prettyprint linenums">
<code>
    public partial class MyClass
    {
        // 定义在文件MyClass1.cs中
    }

    public partial class MyClass
    {
        // 定义在文件MyClass2.cs中
    }
</code>
				</pre>
			</div>

			<div class="title">匿名对象</div>
			<div class="content open">

			</div>	
		</div>
	</div>

	<!--定义对象-->
	<div class="title">定义对象</div>
	<div class="content closed">
		<div class="list list-number">
			<div class="title">定义对象</div>
			<div class="content open">

			</div>

			<div class="title">多态性</div>
			<div class="content open">

			</div>
		</div>
	</div>

	<!--高级功能-->
	<div class="title">高级功能</div>
	<div class="content closed">
		<div class="list list-number">
			<div class="title">对象复制</div>
			<div class="content open">

			</div>

			<div class="title">对象比较</div>
			<div class="content open"></div>

			<div class="title">使用类别库</div>
			<div class="content open">

			</div>

			<div class="title">抽象类 vs 抽象接口</div>
			<div class="content open">

			</div>

			<div class="title">添加迭代器功能</div>
			<div class="content open">

			</div>

			<div class="title">函数调用: 同步 vs 异步</div>
			<div class="content closed">
				<div class="list list-number">
					<div class="title">异步调用范例</div>
					<div class="content open">
						<div class="container-fluid">
							<div class="row">
								<div class="col-7">
									<pre class="prettyprint linenums">
<code>
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("[{0}] [{1:D2}]: {2}", DateTime.Now.ToString("HH:mm:ss"), Thread.CurrentThread.ManagedThreadId, "main");
        for (int i = 0; i < 3; i++) {
            Func&lt;int, int, int> func = new Func&tl;int, int, int>(Add);
            func.BeginInvoke(i, i, AddCallback, null);  // 异步调用
        }

        Console.Read();
    }

    static int Add(int a, int b)
    {
        Console.WriteLine("[{0}] [{1:D2}]: {2} + {3}",
            DateTime.Now.ToString("HH:mm:ss"), Thread.CurrentThread.ManagedThreadId, a, b);
        Thread.Sleep(3000);
        return a + b;
    }

    static void AddCallback(IAsyncResult result)
    {
        Thread.Sleep(3000);
        Func&lt;int, int, int> func = (Func&lt;int, int, int>)((AsyncResult)result).AsyncDelegate;
        Console.WriteLine("[{0}] [{1:D2}]: result = {2}", DateTime.Now.ToString("HH:mm:ss"),
            Thread.CurrentThread.ManagedThreadId, func.EndInvoke(result));
    }
}
</code>
									</pre>	
								</div>
								<div class="col-5">
									<p>输出结果</p>
									<pre class="prettyprint linenums">
<code>
[20:08:41] [09]: main
[20:08:41] [10]: 0 + 0
[20:08:41] [13]: 1 + 1
[20:08:41] [14]: 2 + 2
[20:08:47] [10]: result = 0
[20:08:47] [13]: result = 2
[20:08:47] [14]: result = 4
</code>
									</pre>
									<p>
										说明: 异步调用时, 函数在另外一个线程中执行, 并且回调函数也在这个新线程中执行!
									</p>
								</div>
							</div>
						</div>
					</div>

					<div class="title">XXX</div>
					<div class="content open">

					</div>
				</div>
			</div>
		</div>
	</div>

	<!--对象之间的关系-->
	<div class="title">对象之间的关系</div>
	<div class="content closed">
		<div class="list list-number">
			<div class="title">继承 vs 接口</div>
			<div class="content open">

			</div>

			<div class="title">包含</div>
			<div class="content open">

			</div>

			<div class="title">集合</div>
			<div class="content open">

			</div>
		</div>

	</div>

</div>

{include file="template/footer" /}