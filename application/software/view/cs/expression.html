{include file="template/header" title="C# 表达式" /}

<p>以下章节按最高优先级到最低优先级的顺序列示 C# 运算符。 各章节内运算符的优先级相同。</p>

<div class="list list-number">
    <div class="title">主要运算符</div>
    <div class="content closed">
		<p>x.y: 成员访问. </p>
		<p>x?.y: null条件成员访问. 如果左操作数计算结果为null, 则返回null. </p>
		<p>x?[y]: null条件索引访问. 如果左操作数计算结果为null, 则返回null. </p>
		<p>f(x): 函数调用. </p>
		<p>a[x]: 聚合对象索引. </p>
		<p>x++: 后自增. 先返回x值, 然后用加1后的x值更新存储位置. </p>
		<p>x--: 后自减. 先返回x值, 然后用减1后的x值更新存储位置. </p>
		<p>new: 类型实例化. </p>
		<p>typeof: 返回表示操作数的Type对象. </p>
		<p>checked: 对整数运算启用溢出检查. </p>
		<p>unchecked: 对整数运算禁用溢出检查. 这是默认的编译器行为. </p>
		<p>default(T): 生成类型T的默认值. </p>
		<p>delegate: 声明并返回委托实例. </p>
		<p>sizeof: 返回类型操作数的大小(以字节为单位). </p>
		<p>->: 指针取消引用与成员访问相结合.</p>
    </div>

    <div class="title">一元运算</div>
    <div class="content closed">
		<p>+x: 返回x的值. </p>
		<p>-x: 数值取反. </p>
		<p>!x: 逻辑取反. </p>
		<p>~x: 按位求补. </p>
		<p>++x: 前自增. 先用加1后的x值更新存储位置, 然后返回x值. </p>
		<p>--x: 前自减. 先用减1后的x值更新存储位置, 然后返回x值. </p>
		<p>(T)x: 类型显式转换. </p>
		<p>await: 等待Task. </p>
		<p>&x: 地址. </p>
		<p>*x: 取消引用</p>
    </div>

	<div class="title">乘法运算符</div>
	<div class="content closed">
		<p>x * y: 乘法. </p>
		<p>x / y: 除法. 如果操作数均为整数, 则结果为整数, 舍去小数(例如: -7 / 2 is -3). </p>
		<p>x % y: 余数. 如果操作数均为整数, 则返回x除以y后的余数.</p>
	</div>

	<div class="title">加减运算</div>
	<div class="content closed">
		<p>x + y: 加法. </p>
		<p>x - y: 减法. </p>
	</div>

	<div class="title">移位运算</div>
	<div class="content closed">
		<p>x << y: 左移位, 右侧用0填充. </p>
		<p>x >> y: 右移位. 如果左操作数是int或long, 则左位数补符号位; 如果左操作数是uint或ulong, 则左位数补零. </p>
	</div>

	<div class="title">关系和类型测试运算</div>
	<div class="content closed">
		<p>x < y: 小于(如果x小于y, 则为true). </p> 
		<p>x > y: 大于(如果x大于y, 则为true). </p>
		<p>x <= y: 小于或等于. </p>
		<p>x >= y: 大于或等于. </p>
		<p>is: 类型兼容性. 如果求值后的左操作数可以转换为右操作数中指定的类型(静态类型), 则返回true. </p>
		<p>as: 类型转换. 返回左操作数数并转换为右做操作数中指定的类型(静态类型), 如果转换失败, 则返回null, 不像(T)x会引发异常. </p>
	</div>

	<div class="title">相等运算</div>
	<div class="content closed">
		<p>
			x == y: 相等. <br>
			对于预定义的值类型，如果其操作数的值相等，则相等运算符 (==) 返回 true，否则返回 false。 对于 string 外的引用类型，如果两个操作数引用同一对象，则 == 会返回 true。 对于 string 类型，== 会比较字符串的值。<br>
			但是，类型可以重载 ==，因此，如果你想测试标识，最好对 object 使用 ReferenceEquals 方法。
		</p>
		<p>
			x != y: 不相等. 请参考==的注释.
		</p>
	</div>

	<div class="title">位与</div>
	<div class="content closed">
		<p>x & y: 按位与. 通常可以将此运算符与整数类型和enum类型一起使用.</p>
	</div>

	<div class="title">位异或</div>
	<div class="content closed">
		<p>x ^ y: 按位异或. 通常可以将此运算符与整数类型和enum类型一起使用.</p>
	</div>

	<div class="title">位或</div>
	<div class="content closed">
		<p>x | y: 按位或. 通常可以将此运算符与整数类型和enum类型一起使用.</p>
	</div>

	<div class="title">逻辑与</div>
	<div class="content closed">
		<p>x && y: 逻辑与. 如果第一个操作数计算结果为 false，则 C# 不对第二个操作数求值.</p>
	</div>

	<div class="title">逻辑或</div>
	<div class="content closed">
		<p>x || y: 逻辑或. 如果第一个操作数计算结果为 true，则 C# 不对第二个操作数求值.</p>
	</div>

	<div class="title">null合并</div>
	<div class="content closed">
		<p>x ?? y: 如果x不为null, 则返回x; 否则返回y.</p>
	</div>

	<div class="title">条件运算</div>
	<div class="content closed">
		<p>t? x:y: 如果测试 t 计算结果为 true，则计算并返回 x；否则，计算并返回 y。</p>
	</div>

	<div class="title">赋值和Lambda运算</div>
	<div class="content closed">
		<p>x = y: 赋值</p>
		<p>x += y: 递增。 x 值加 y 值，结果存储在 x 中，并返回新值。 如果 x 指定 event，则 y 必须是 C# 作为事件处理程序添加的相应函数.</p>
		<p>x -= y: 递减。 x 值减 y 值，结果存储在 x 中，并返回新值。 如果 x 指定 event，则 y 必须是 C# 作为事件处理程序删除的相应函数.</p>
		<p>x *= y: 乘法赋值。 x 值乘以 y 值，结果存储在 x 中，并返回新值。</p>
		<p>x /= y: 除法赋值。 x 值除以 y 值，结果存储在 x 中，并返回新值。</p>
		<p>x %= y: 余数赋值。 x 值除以 y 值，余数存储在 x 中，并返回新值。</p>
		<p>x &= y: 位与赋值.  y 值和 x 值相与，结果存储在 x 中，并返回新值。</p>
		<p>x |= y: 位或赋值. y 值和 x 值相或，结果存储在 x 中，并返回新值。</p>
		<p>x ^= y: 位异或赋值. y 值和 x 值相异或，结果存储在 x 中，并返回新值。</p>
		<p>x <<=y: 位左移赋值.  将 x 值向左移动 y 位，结果存储在 x 中，并返回新值。</p>
		<p>x >>=y: 位右移赋值. 将 x 值向右移动 y 位，结果存储在 x 中，并返回新值。</p>
		<p>=>: lambda声明.</p>
		<p></p>
	</div>

	<br>
	<div class="title">算术溢出</div>
	<div class="content closed">
		<p>算术运算符（+、-、*、/）的计算结果可能会超出所涉数值类型的可取值范围。 详细信息应参考特定运算符的相关章节，而一般情况下：</p>	
		<div class="list list-square">
			<div class="title">整数算术溢出或者引发 OverflowException，或者放弃结果的最高有效位。 整数被零除总是引发 DivideByZeroException。</div>
			<div class="content open">
				<p>
					发生整数溢出时，具体影响视执行上下文而定，上下文可为 checked 或 unchecked。 在 checked 上下文中引发 OverflowException。 在 unchecked 上下文中，放弃结果的最高有效位并继续执行。 因此，C# 让你有机会选择处理或忽略溢出。 默认情况下，算术运算发生在 unchecked 上下文中。
				</p>
				<p>
					除算术运算以外，整型类型之间的显式转换也会导致溢出（例如，将 long 显式转换成 int），并受到 checked 或 unchecked 执行的约束。 但是，位运算符和移位运算符永远不会导致溢出。
				</p>
			</div>

			<div class="title">浮点算术溢出或被零除从不引发异常，因为浮点类型基于 IEEE 754，因此可以表示无穷大和 NaN（非数值）。</div>
			<div class="content open">
			</div>

			<div class="title">decimal算术溢出总是引发 OverflowException。 decimal被零除总是引发 DivideByZeroException。</div>
			<div class="content closed"></div>
		</div>
	</div>
</div>

<hr>
<p>
	参考<br>
	<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/index">C#运算符</a>
</p>
{include file="template/footer" /}