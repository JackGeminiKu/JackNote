{include file="template/header" title="C# 数据" /}
<p>
    <strong>C#是一种静态类型编程语言, 但是现在有dynamic类型!</strong>
</p>

<div class="list list-number">
    <!--数据类型-->
    <div class="title">数据类型</div>
    <div class="content open">
        <div class="container ml-0">
            <div class="row">
                <div class="col-1"><strong>基本类型: </strong></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-object')}">Object</a></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-string')}">字符串</a></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-bool')}">bool</a></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-int')}">整数</a></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-float')}">浮点数</a></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-datetime')}">日期时间</a></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-nullable')}">可空类型</a></div>
            </div>	

            <div class="row">
                <div class="col-1"><strong>数据结构</strong></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-class')}">类</a></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-interface')}">接口</a></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-struct')}">结构体</a></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-enum')}">枚举</a></div>
            </div>

            <div class="row">
                <div class="col-1"><strong>容器类</strong></div>
                <div class="col-2">
                    <a href="{:url('software/cs/index', 'template=cs-data-array')}">Array</a><br>
                    <a href="{:url('software/cs/index', 'template=cs-data-list')}">List&lt;T></a><br>
                    <a href="{:url('software/cs/index', 'template=cs-data-array_list')}">ArrayList</a><br>
                    <a href="{:url('software/cs/index', 'template=cs-data-collection_base')}">CollectionBase</a><br>
                    ReadOnlyCollection&lt;T>
                </div>
                <div class="col-3">
                    Dictionary&lt;K,V><br>
                    Hashtable<br>
                    DictionaryBase
                </div>
                <div class="col-3">
                    Stack<br>
                    HashSet&ltT>
                </div>
            </div>

            <div class="row">
                <div class="col-1"><strong>特殊类型</strong></div>
                <div class="col-1"><a href="{:url('software/cs/index', 'template=cs-data-delegate')}">委托</a></div>
                <div class="col-1">dynamic</div>
            </div>
        </div>

		<div class="list list-square pl-3">
			<div class="title">值类型&引用类型</div>
			<div class="content closed">
				<p>
					两种类型的变量都存储在堆栈中, 区别是: 值类型变量中存储的就是值本身, 而引用类型变量中存储的是地址, 这个地址指向堆中的对象! <br>
					所以值类型赋值时, 拷贝的是值; 引用类型赋值时, 拷贝的是"地址".<br>                
					<img src="__ROOT__/static/image/cs/值类型.png" width="445" height="196">       
					<img src="__ROOT__/static/image/cs/引用类型.png" width="445" height="196">
				</p>

				<p class="text-danger">
					值类型只有6中: 包括bool, char, 整数, 浮点数 & 结构体. 剩下的都是引用类型.
				</p>
			</div>

			<div class="title">装箱&拆箱</div>
			<div class="content closed">
				<p><strong>装箱: 把值类型赋给Object类型</strong></p>
				<pre class="prettyprint linenums lang-cs"><code>Currency balance = new Currency(40, 0);  // Currency是结构体, 所以是值类型
object baseCopy = balance;  // 装箱: 引用类型指向了值类型</code></pre>
				<p>
					在最初定义Currency结构体时, .NET自动提供了另一个"隐式"类, 即装箱Currency类, 它包含与Currency结构相同的所有字段, 但却是一个引用类型, 存储在堆上. 所有值类型都存在类似的装箱引用类型！
				</p>
				<p>
					在隐式地把Currency转换为Object时, 会实例化一个新的装箱Currency实例, 并用Currency结构中的所有数据进行初始化, 在上例中, baseCopy对象引用的就是这个装箱Currency实例.
				</p>


				<p><strong>拆箱: 装箱的反过程, 即把Object类型"赋给"值类型</strong></p>
				<p>
					拆箱是装箱的相反过程. 由于是一种显示转换, 转换时可能会抛异常!
				</p>
				<pre class="prettyprint linenums lang-php">
<code>object derivedObject = new Currency(40, 0);
object baseObject = new object();
Currency derivedCopy1 = (Currency)derivedObject;    // 拆箱
Currency derivedCopy2 = (Currency)baseObject;       // Exception thrown
</code>
				</pre>	
			</div>

			<div class="title">托管&非托管类型</div>
			<div class="content closed">
				<p>详见资源释放专题!</p>
			</div>
		</div>
    </div>

    <!--常量/变量-->
    <div class="title">常量/变量</div>
    <div class="content closed">
        <div class="list list-number">
            <div class="title">常量</div>
            <div class="content open">
				<div class="list list-number">
					<div class="title">定义常量</div>
					<div class="content open">
						<pre class="prettyprint linenums lang-cs">
<code>
const / readonly double PI = 3.14;    // 变量名一般用大写表示, 单词之间用"_"连接. 使用常量可以避免重复, 避免被修改, 增强程序可读性
</code>
						</pre>

						<table class="w-75">
							<tbody>                        
								<tr>
									<th></th>
									<th>const: 类常量</th>
									<th>readonly: 对象常量</th>
								</tr>
								<tr>
									<th>声明位置</th>
									<td>类里面, 或者函数内</td>
									<td>类里面</td>
								</tr>
								<tr>
									<th>初始化</th>
									<td>声明时</td>
									<td>声明时 + 构造函数中 (声明时的顺序可能会对值造成影响, 可以把所有的ReadOnly声明看成一段代码)</td>                                
								</tr>
								<tr>
									<th>类型限制</th>
									<td>只能是值类型</td>
									<td>任何类型</td>
								</tr>
								<tr>
									<th>对于对象而言</th>
									<td>对于类的所有对象而言, 常量的值都是一样的</td>
									<td>对于类的不同对象而言, 常量的值可以是不一样的</td>
								</tr>
							</tbody>
						</table>
						<br>
						<p>注意: const常量总是静态的, 但是不必在常量声明中包含修饰符static.</p>
					</div>

					<div class="title">常量命名规则</div>
					<div class="content open">
						<p>大写, 单词间用"_"连接</p>
					</div>
				</div>
            </div>

            <div class="title">变量</div>
            <div class="content open">

				<div class="list list-number">
					<div class="title">变量声明</div>
					<div class="content open">
						<pre class="prettyprint linenums lang-cs">
<code>int i = 0;
var i = 0;  // 隐式类型, 变量的类型由后面的值决定 (Since .NET 3.0)
Person p = new Person() { Name = "Jack" };  // 初始化器 = 构造对象 + 属性赋值 (since .NET 3.0)
</code>
						</pre>
					</div>

					<div class="title">变量命名规则</div>
					<div class="content open">
						<p>
							1) 变量名关系到程序的可读性, 所以变量名要起的有意义.<br>
							2) 以字母, 下划线(_) 或@开头, 后续字符可以是字母, 数字和下划线<br>
							3) 区分大小写, 建议采用camelCase规则.<br>
							注: 如果变量名和关键字同名, 可以在前面加个'@'符号, 例如: @if.
						</p>
					</div>
				</div>
            </div>
        </div>
    </div>

    <!--局部/全局-->
    <div class="title">作用域: 局部/全局</div>
    <div class="content closed">
        <p>
            1) 局部变量/常量: 在函数中定义, 只能在当前{}中使用<br>
            2) 全局变量/常量: 在函数外定义, 可以在当前类中使用. - 尽量少用全局变量!<br><br>

            注意: 同名局部变量/常量会遮挡全局变量/常量的作用域!
        </p>
    </div>

    <div class="title">访问权限控制</div>
    <div class="content closed">
        <p>            
            private: 	仅对当前类公开<br>
            protected: 	对当前类及其派生类公开<br>
            internal:   对当前程序集公开<br>
            public:		对任何类都公开<br>
            protected internal: protected或者internal<br>
        </p>
    </div>

    <!--数据类型转换-->
    <div class="title">数据类型转换</div>
    <div class="content closed">
        <div class="list list-number">
            <div class="title">隐式转换</div>
            <div class="content open">
                <p>赋值时, 如果两边类型不一致, C#就会尝试隐式转换. 但是隐式转换不能保证100%成功, 转换失败编译器会报错. C#支持的隐式类型转换如下:</p>
                <div class="container ml-0">
                    <div class="row">
                        <div class="col-6">
                            <p><strong>数值</strong></p>
                            <table>
                                <tbody>
                                    <tr>
                                        <td>sbyte</td>
                                        <td rowspan="9"> => </td>
                                        <td>short, int, long, float, double, decimal</td>
                                    </tr>
                                    <tr>
                                        <td>byte</td>
                                        <td>short, ushort, int, uint, long, ulong, float, double, decimal</td>
                                    </tr>
                                    <tr>
                                        <td>short</td>
                                        <td>int, long, float, double, decimal</td>
                                    </tr>
                                    <tr>
                                        <td>ushort</td>
                                        <td>int, uint, long, ulong, float, double, decimal</td>
                                    </tr>
                                    <tr>
                                        <td>int</td>
                                        <td>long, float, double, decimal</td>
                                    </tr>
                                    <tr>
                                        <td>uint</td>
                                        <td>long, ulong, float, double, decimal</td>
                                    </tr>
                                    <tr>
                                        <td>long,ulong</td>
                                        <td>float, double, decimal</td>
                                    </tr>
                                    <tr>
                                        <td>float</td>
                                        <td>double</td>
                                    </tr>
                                    <tr>
                                        <td>char</td>
                                        <td>ushort, int, uint, long, ulong, float, double, decimal</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>
                                注意: <br>
                                ① 只能从较小的整数类型隐式地转换为较大的整数类型, 反过来则不能转换.<br>
                                ② 无符号的数可以转换为有符号数, 只要无符号数的大小在有符号数的范围之内即可.
                            </p>
                        </div>
                        <div class="col-6">
                            <p><strong>可空类型</strong></p>
                            <p>
                                1) 可空类型 ==> 其他可空类型, 应遵循上表中非可空类型的转换原则. <br>
                                2) 非可空类型 ==> 可空类型, 也应遵循上表中的转换原则.<br>
                                3) 可空类型 ==> 非可空类型是不可以的, 此时必须进行显示转换. 这是因为可空类型的值可以是null, 但非可空类型不能表示这个值.<
                            </p>
                        </div>
                    </div>	
                </div>
            </div>

            <div class="title">显示转换</div>
            <div class="content open">
                <div class="container-fluid ml-0">
                    <div class="row">
                        <div class="col-6">
                            <div class="list list-square">
                                <div class="title">(type)转换 - 可能不能转换, 就算转换了也可能会失败</div>
                                <div class="content open">
                                    <p><strong>数值类型转换</strong></p>
                                    <pre class="prettyprint linenums lang-cs"><code>long val = 30000;
int i = (int)val;</code></pre>

                                    <p>显示转换是一种比较危险的操作, 即使在从long转换为int这样简单的转换过程中, 可能也会出问题.</p>
                                    <pre class="prettyprint linenums lang-cs"><code>long val = 3000000000;
int i = (int)val;   // i = -1294967296</code></pre>

                                    <p>在上例中, 不会报错, 但是得不到期望的结果. 因此C#提供了一个checked运算符, 如果操作产生算术溢出, 就会抛出一个运行时错误.</p>
                                    <pre class="prettyprint linenums lang-php"><code>checked {
    long val = 3000000000;
    int i = (int)val;   // 抛出溢出异常
}</code></pre>
                                    <p>
                                        总之, 在进行(type)转换时有一些限制, 例如:<br>
                                        1) 值类型, 只能在数字, char类型和enum类型之间转换; <br>
                                        2) 不能直接把bool类型转换为其他类型, 也不能把其他类型转换为bool类型, 否则编译会出错.<br>
                                        而且所有的(type)转化都可能不安全, 在 程序中应使用checked关键字, 处理可能失败的数据类型转换.
                                    </p>

                                    <p>修改溢出检查的默认设置:  在C#中, 打开Project 属性, 单击Advanced按钮, 在打开的对话框中, 选中Check for arithmetic overflow/underflow选项...</p>

                                    <p><strong>父类&子类之间的数据类型转换</strong></p>
                                    <p>编译器已经提供了基类和派生类之间的转换, 实际上, 这种转换并没有对对象进行任何数据转换, 只是改变一下引用“指向”而已!</p>
                                    <pre class="prettyprint linenums lang-php"><code>Animal a = new Dog();  // 基类可以指向派生类, 基类数组也可以指向派生类数组(和多态放在一起?)
Animal a2 = new Animal();
 
Dog d1 = (Dog)a;    // 可以指向本类对象, 也可以指向子类对象
Dog d2 = (Dog)a2;   // 不能指向本类/子类对象， 抛出运行时异常</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="list list-square">
                                <div class="title">转换成引用类型 - 转换失败返回null</div>
                                <div class="content open">
                                    <pre class="prettyprint linenums lang-php"><code>something as sometype</code></pre>
                                    <p>
                                        把一种类型转换为指定的引用类型, 如果转换失败时, 表达式的值为null!<br><br>

                                        这只适用于下列情况:<br>
                                        1) something的类型是sometype类型.<br>
                                        2) something可以隐式转换为sometype类型.<br>
                                        3) something可以封箱到类型sometype中.
                                    </p>
                                </div>

                                <div class="title">使用目标类型的静态方法: Parse() & TryParse()</div>
                                <div class="content open">
                                    <pre class="prettyprint linenums lang-php"><code>public static byte Parse (string s)                         // 失败抛异常
public static bool TryParse (string s, out byte result )    // 失败返回false</code></pre>
                                </div>

                                <div class="title">使用Convert类 - 转换成常用类型 - 可能抛出错误</div>
                                <div class="content open">
                                    <pre class="prettyprint linenums lang-php"><code>Convert.ToByte(val)等等  // 转换溢出, 或者转换失败, 会抛出异常!
public static Object ChangeType ( Object value, Type conversionType )</code></pre>
                                </div>

                                <div class="title">使用TypeConverter类: String ==> XXX</div>
                                <div class="content open">
                                    <pre class="prettyprint linenums lang-php"><code>object o = new XXX() ;
object o2;
 
TypeConverter converter = TypeDescriptor.GetConverter(typeof(XXX));
try {
    o2 = converter.ConvertFromInvariantString(o.ToString());
} catch (Exception ex) {
    Console.WriteLine("The conversion cannot be performed: " + ex.Message);
}</code></pre>
                                </div>

								<div class="title">byte[]互转</div>
								<div class="content open">
									<pre class="prettyprint linenums lang-php"><code>BitConverter.ToUInt32(BitConverter.GetBytes(0x1234), 0);	// 小端字节</code></pre>
								</div>
                            </div>
                        </div>
                    </div>	
                </div>
            </div>

            <div class="title">重载转换运算符</div>
            <div class="content open">
                <p>详见类的定义部分</p>
            </div>
        </div>
    </div>

    <!--数据类型判断-->
    <div class="title">数据类型判断</div>
    <div class="content closed">
        <div class="container ml-0">
            <div class="row">
                <div class="col-3">判断类型是否相等</div>
                <div class="col-6">typof(T1) == typeof(T2)</div>
            </div>	
            <div class="row">
                <div class="col-3">判断某种类型是否是XXX类型的子类</div>
                <div class="col-6">t.IsSubclassOf(XXX)</div>
            </div>
            <div class="row">
                <div class="col-3">判断某种类型是否实现了XXX接口</div>
                <div class="col-6">typeof(IXXX).IsAssignableFrom(typeof(BarClass))</div>
            </div>
            <div class="row">
                <div class="col-3">判断某个对象是否是T系列</div>
                <div class="col-6">o != null && typeof(T).IsAssignableFrom(o.GetType()) 或者 o is T</div>
            </div>
            <div class="row">
                <div class="col-3">判断某个对象是否是XXX类型</div>
                <div class="col-6">obj != null && obj.GetType() == typeof(XXX)</div>
            </div>
            <div class="row">
                <div class="col-3">判断某种类型是否是某种泛型</div>
                <div class="col-6">t.IsGenericType && t.GetGenericTypeDefinition() == typeof(Dictionary<,>)</div>
            </div>
        </div>
    </div>

    <!--数据相等比较-->
    <div class="title">数据相等比较</div>
    <div class="content closed">
        <div class="list list-square">
            <div class="title">引用类型比较</div>
            <div class="content open">
                <p>
                    比较两个对象的引用(内存地址)是否相等. 关于null: null和null比较， 则返回true; 只有一个为null时, 返回false.
                </p>
                <p>
                    虚拟方法(可以重写): object.Equals(obj)<br>
                    静态方法(不能重写): Object.ReferenceEquals(objA, objB); Object.Equals(objA, objB)<br>                    
                </p>

                <p>
                    System.ValueType类中已经重载了Equals()方法, 以便对值类型进进行合适的相等测试.<br>
                    引用比较应用于值类型时, 总是返回false, 因为为了调用这个方法, 值类型需要装箱到对象中, 这意味着会得到不同的引用.
                </p>
            </div>

            <div class="title">a == b</div>
            <div class="content open">
                <p>
                    对于值类型和string类型，如果操作数的值相等，则返回true，否则返回false.<br>
                    对于引用类型(string除外)，如果两个操作数引用同一个对象，则返回 true.
                </p>
            </div>
        </div>
    </div>

    <!--命名空间-->
    <div class="title">命名空间</div>
    <div class="content closed">
        <p>数据类型位于命名空间中, 命名空间是存放数据类型的"容器". 同一命名空间内的数据类型相互之间可以直接使用, 当前命名空间中的类型名字可以和其他命名空间中的类型名字相同.</p>
        <div class="list list-square">
            <div class="title">定义命名空间</div>
            <div class="content open">
                <pre class="prettyprint linenums lang-cs"><code>namespace Simplo.Test  // 微软建议至少要提供两个嵌套的命名空间, 第一个是公司名, 第二个是技术名称/软件包的名称, 在大多数情况下, 这么做可以保证类名不会与其他组织编写的类名冲突.
{
    public class Power ...
}</code></pre>
            </div>

            <div class="title">声明命名空间</div>
            <div class="content open">
                <pre class="prettyprint linenums lang-cs"><code>using Simplo.Test;   // 在当前命名空间中使用另一个命名空间中的数据类型时， 可以使用using进行声明， 这样类型名前面就可以不用指定冗长的命名空间了</code></pre>
            </div>

            <div class="title">定义别名</div>
            <div class="content open">
                <pre class="prettyprint linenums lang-cs"><code>using MyAlias = Simplo.Test;                              // 定义别名
　
MyAlias::Power power;                                     // 使用别名: 使用::运算符, 编译器会优先使用using语句定义的别名
global::System.Collections.Generic.List&lt;int> list;        // global别名: global别名实际上是顶级根命名空间的别名</code></pre>
            </div>

            <div class="title">外部别名</div>
            <div class="content open">
                <p>
                    http://www.cnblogs.com/Insein/p/6290439.html<br>
                    https://stackoverflow.com/questions/2502640/the-extern-alias-xxx-was-not-specified-in-a-reference-option/<br>
                </p>                
            </div>
        </div>

    </div>
</div>
{include file="template/footer" /}