{include file="template/header" title="C#数据 枚举" /}
<p>枚举类型的意义: 限制用户不能随意赋值, 只能在定义枚举时列举的值中选择; 不需要死记硬背每一个值是什么, 只需要选择相应的值.</p>
<pre class="prettyprint linenums">
<code>
enum Orientation : int
{
    [Description("北")]
    North = 1,
    [Description("南")]
    South = 2,
    [Description("东")]
    East = 4,
    [Description("西")]
    West = 8
}
</code>
</pre>
<p>枚举使用一个整型来存储, 默认为int, 也可以指定其他整型.</p>
<p>
	默认情况下, 每个值都会根据定义的顺序, 从0开始自动赋值. 但是可以重写这个赋值过程: 使用=运算符, 并制定每个枚举的实际值; 没有赋值的任何值都会自动获得一个初始值, 这里使用的值是从比最后一个明确声明的值大1开始的序列
</p>
<p>在C#中, 枚举的真正强大之处是它们在后台会实例化派生于基类System.Enum的结构. 这表示可以对它们调用方法, 执行有用的任务. 实际上, 一旦代码编译好, 枚举就成为基本类型, 与int和float等类似.</p>

<div class="list list-number">
    <div class="title">类型转换</div>
    <div class="content closed">
		<div class="list list-number">
			<div class="title">枚举 <==> 整数</div>
			<div class="content open">
				<pre class="prettyprint linenums">
<code>
directionByte = (int) myDirection;    // 即使Orientation的基本类型是int, 仍必须使用(int)数据类型转换
myDirection = (Orientation) myInt;    // 如果要把int类型转换为Orientation, 也需要进行显示转换. 注意: 如果myInt的值没有映射为已定义的Orientation, 程式不会报错.
</code>
				</pre>
			</div>

			<div class="title">枚举 <==> 字符串</div>
			<div class="content open">
				<pre class="prettyprint linenums">
<code>
// 枚举 ==> 字符串
directionString = myDirection.ToString();           // 方法1
directionString = Convert.ToString(myDirection);    // 方法2
// 字符串 ==> 枚举
Orientation myDirection = (Orientation)Enum.Parse(typeof(Orientation),"North");    // 并不是所有的字符串都会映射为一个Orientation值, 如果一个值不能映射为枚举值中的一个, 就会产生错误.
</code>
				</pre>
			</div>
		</div> 
    </div>

    <div class="title">遍历枚举类型</div>
    <div class="content closed">
		<pre class="prettyprint linenums">
<code>
foreach (ETestItem eTestItem in Enum.GetValues(typeof(ETestItem))) {
    // Enum.GetValues(typeof(ETestItem)返回一个数组
}
</code>
		</pre>
    </div>

	<div class="title">动态创建枚举</div>
    <div class="content closed">
		<pre class="prettyprint linenums">
<code>
using System;
using System.Collections;
using System.Threading;
using System.Reflection;
using System.Reflection.Emit;
 
public class MyEnumBuilderSample
{
    static AssemblyBuilder myAssemblyBuilder;
    static ModuleBuilder myModuleBuilder;
    static EnumBuilder myEnumBuilder;
 
    public static void Main()
    {
        try {
            CreateCallee(Thread.GetDomain(), AssemblyBuilderAccess.Save);
            Type[] myTypeArray = myModuleBuilder.GetTypes();
            foreach (Type myType in myTypeArray) {
                Console.WriteLine("Enum Builder defined in the module builder is: " + myType.Name);
            }
 
            Console.WriteLine("Enum TypeToken is :" + myEnumBuilder.TypeToken.ToString());
            Console.WriteLine("Enum UnderLyingField is :" + myEnumBuilder.UnderlyingField.ToString());
            Console.WriteLine("Enum UnderLyingSystemType is :" + myEnumBuilder.UnderlyingSystemType.ToString());
            Console.WriteLine("Enum GUID is :" + myEnumBuilder.GUID.ToString());
            myAssemblyBuilder.Save("EmittedAssembly.dll");
        }
        catch (NotSupportedException ex) {
            Console.WriteLine("The following is the exception is raised: " + ex.Message);
        }
        catch (Exception e) {
            Console.WriteLine("The following is the exception raised: " + e.Message);
        }
    }
 
    private static void CreateCallee(AppDomain myAppDomain, AssemblyBuilderAccess access)
    {
        // Create a name for the assembly.
        AssemblyName myAssemblyName = new AssemblyName();
        myAssemblyName.Name = "EmittedAssembly";
 
        // Create the dynamic assembly.
        myAssemblyBuilder = myAppDomain.DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.Save);
        // Create a dynamic module.
        myModuleBuilder = myAssemblyBuilder.DefineDynamicModule("EmittedModule", "EmittedModule.mod");
        // Create a dynamic Enum.
        myEnumBuilder = myModuleBuilder.DefineEnum("MyNamespace.MyEnum", TypeAttributes.Public, typeof(Int32));
 
        FieldBuilder myFieldBuilder1 = myEnumBuilder.DefineLiteral("FieldOne", 1);
        FieldBuilder myFieldBuilder2 = myEnumBuilder.DefineLiteral("FieldTwo", 2);
 
        myEnumBuilder.CreateType();
    }
}
</code>
		</pre>
		<p>My other projects in the solution reference this generated assembly. As a result, I can then use the dynamic enums in code, complete with intellisense.</p>

		<p>Then, I added a post-build event so that after this "EnumeratedTypes" project is built, it runs itself and generates the "MyEnums.dll" file.
		</p>

		<p>By the way, it helps to change the build order of your project so that "EnumeratedTypes" is built first. Otherwise, once you start using your dynamically generated .dll, you won't be able to do a build if the .dll ever gets deleted. (Chicken and egg kind of problem -- your other projects in the solution need this .dll to build properly, and you can't create the .dll until you build your solution...)</p>
    </div>

	<div class="title">仿枚举</div>
    <div class="content closed">
		<pre class="prettyprint linenums">
<code>
public sealed class Operation
{
    public static readonly Operation Name1 = new Operation("Operation1");
    public static readonly Operation Name2 = new Operation("Operation2");

    private string m_sValue;

    private Operation(string value)
    {
        Value = value;
    }

    public string Value
    {
        get
        { return m_sValue; }
        private set
        { m_sValue = value; }
    }
}
</code>
		</pre>
    </div>
</div>
{include file="template/footer" /}