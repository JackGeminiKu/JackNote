{include file="template/header" title="C# 流程控制" /}
<div class="list list-number">
    <!--条件-->
    <div class="title">条件</div>
    <div class="content open">
        <div class="containter ml-0 w-75">
            <div class="row">
				<div class="col-2">
					<pre class="prettyprint linenums lang-cs">
<code>
// if
if (条件) {              
    ...
}
</code>
					</pre>	
				</div>

				<div class="col-2">
					<pre class="prettyprint linenums lang-cs">
<code>
// if else
if (条件) {
	...
} else {
    ...
}
</code>
					</pre>	
				</div>

				<div class="col-2">
                    <pre class="prettyprint linenums lang-cs">
<code>
// else if
if (条件1) {            
    ...
} else if (条件2) {
    ...
} else {
    ...
}
</code>
					</pre>
                </div>

                <div class="col-6">
                    <pre class="prettyprint linenums lang-cs">
<code>
	switch (条件) {    // 条件值只能是简单数据类型: 整型, 字符串或浮点型
    case 条件值1:
        ...
        break;
    case 条件值2:
        ...
        break;
    default:
        ...
        break;
}
</code>
					</pre>
                </div>
            </div> 

            <div class="row">
                <div class="col-10">
                    <p>备注: 条件语句一定要把情况考虑清楚, 不要忘了else情况和default情况, 不一定在代码上体现出来, 但是心里一定要默默考虑到!</p>
                </div>
            </div>
        </div>
    </div>

    <!--循环-->
    <div class="title">循环</div>
    <div class="content open">
        <div class="container-fluid ml-0">
            <div class="row">
                <div class="col-2">
                    while循环
                </div>
                <div class="col-2">
                    do while循环
                </div>
                <div class="col-2">
                    for循环
                </div>
            </div>

            <div class="row">
                <div class="col-2">
                    <pre class="prettyprint linenums lang-cs">
<code>
while (条件) {    
    ...
}
</code>
					</pre>
                </div>
                <div class="col-2">
                    <pre class="prettyprint linenums lang-cs">
<code>
do {    
    ...
} while(条件)
</code>
					</pre>
                </div>
                <div class="col-2">
                    <pre class="prettyprint linenums lang-cs">
<code>
for (初始化; 条件; 更新) {    
    ...
}
</code>
					</pre>
                </div>
            </div>

            <div class="row">
                <div class="col-12">
                    <div class="col-3">
                        foreach循环(实现了IEnumerable的类, 只读)
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-3">
                    <pre class="prettyprint linenums lang-cs">
<code>
foreach (int item in array) {    
    // 数组类
}
</code>
					</pre>
                </div>
                <div class="col-3">
                    <pre class="prettyprint linenums lang-cs">
<code>
foreach (KeyValuePair&lt;string, int> item in dic) {    
    // 字典类
}
</code>
					</pre>
                </div>
                <div class="col-3">
                    <pre class="prettyprint linenums lang-cs">
<code>
foreach (DictionaryEntry item in hashtable) {    
    // 字典类
}
</code>
					</pre>
                </div>
            </div>
        </div>
    </div>

    <!--跳转-->
    <div class="title">跳转</div>
    <div class="content open">
        <p>break; &emsp; continue; &emsp; return; &emsp; </p>
    </div>

    <!--异常处理-->
    <div class="title">异常处理</div>
    <div class="content closed">
		<div class="list list-number">

			<!--使用异常的正确姿势-->
			<div class="title">异常抛出&捕捉</div>
			<div class="content closed">
				<div class="container-fluid pl-0">
					<div class="row">
						<div class="col-6">
							<p class="text-strong">捕捉异常</p>
							<pre class="prettyprint linenums">
<code>
try {
    // 产生异常的代码块, 发生异常时: 直接跳转到catch区域, try区域中发生异常之后的语句不会执行
} catch ( Exception_Type e ) {
    // catch块可以使用Exception_Type, 设置为只响应特定的异常类型; 也可以省略这个参数, 设置为响应所有的异常.
    // 捕捉当前线程的异常???
} finally {
    // 不管是否产生异常, 都会执行的代码.
}
</code>
							</pre>
						</div>
						<div class="col-6">
							<p class="text-strong">抛出异常</p>
							<pre class="prettyprint linenums">
<code>
throw ( new Exception() );
throw;    // 这个表达式会产生一个异常, 这个异常同这个catch块处理过的异常一样.
</code>
							</pre>
							<p>配置异常: Ctrl + Alt + E</p>
						</div>

					</div>
				</div>
			</div>

			<!--常用异常类-->
			<div class="title">系统异常类 & 自定义异常类</div>
			<div class="content closed">
				<p class="text-strong">常用系统异常类</p>
				<p>
					Exception, <br>
					ArgumentException, <br>
					ArgumentNullExcpetion, <br>
					InvalidOperationException: The exception that is thrown when a method call is invalid for the object's current state.
				</p>
				<p class="text-strong">自定义异常类</p>
				<pre class="prettyprint linenums">
<code>
public class CardOutOfRangeException : Exception
{
    private Cards deckContents;
   
    public Cards DeckContents
    {
        get { return deckContents; }
    }

    public CardOutOfRangeException(Cards sourceDeckContents)
        :base("There are only 52 cards in the deck.")
    {
        deckContents = sourceDeckContents;
    }
}
</code>
				</pre>
			</div>

			<div class="title">异常对性能的影响</div>
			<div class="content closed">
				<a href="http://www.mamicode.com/info-detail-99312.html">网上资料</a>
			</div>

			<!--未捕获的异常-->
			<div class="title">未捕获的异常</div>
			<div class="content closed">
				<div class="list list-number">
					<div class="title">应用程序域异常: appDomain.UnhandledExcpetion</div>
					<div class="content closed">
						<pre class="prettyprint linenums">
<code>
static void Main(string[] args)
{
    // 应用程序域中的未捕捉异常将触发UnhandledException事件!
    AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
}

static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
{
    Exception error = (Exception)e.ExceptionObject;
    Console.WriteLine("MyHandler caught : " + error.Message);
}
</code>
						</pre>
						<p class="text-danger">注意: UnhandledException提供的机制并不能阻止应用程序终止，也就是说，CurrentDomain_UnhandledException方法执行后，应用程序就会被终止。</p>
					</div>

					<div class="title">WinForm UI异常: Application.ThreadException</div>
					<div class="content closed">
						<pre class="prettyprint linenums">
<code>
[STAThread]
static void Main()
{
    // 启用Application.ThreadException: 对于应用程序域中的所有未捕获异常, UI线程的异常将触发ThreadException事件, 其他线程的异常将触发UnhandledException事件.
    AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
    Application.ThreadException += new ThreadExceptionEventHandler(UI_ThreadException);
    Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);
　
    Application.Run(new ErrorHandlerForm());
}
 
private static void UI_ThreadException(object sender, ThreadExceptionEventArgs t)
{
    try {
        MessageBox.Show("Windows窗体线程异常: " + Environment.NewLine + t.Exception.Message + Environment.NewLine + t.Exception.StackTrace);
    } catch {
        MessageBox.Show("不可恢复的Windows窗体异常，应用程序 即将退出！");
    }
}
 
private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
{
    try {
        Exception ex = (Exception)e.ExceptionObject;
        MessageBox.Show("非窗体线程异常: " + Environment.NewLine + ex.Message + Environment.NewLine + ex.StackTrace);
    } catch {
        MessageBox.Show("不可恢复的非Windows窗体线程异常，应用程序 即将退出！");
    }
}
</code>
						</pre>
					</div>

					<div class="title">WPF UI异常: this.DispatcherUnhandledException </div>
					<div class="content closed">
						<pre class="prettyprint linenums">
<code>
public App()
{
    // 启用this.DispatcherUnhandledException: 对于应用程序域中的所有未捕获异常, UI线程的异常将触发DispatcherUnhandledException事件, 其他线程的异常将触发UnhandledException事件.
    AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);    // 非UI异常
    this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Application_DispatcherUnhandledException);    // WPF异常
}
 
void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
{
    try {
        Exception ex = e.ExceptionObject as Exception;
        MessageBox.Show("非WPF窗体线程异常: " + Environment.NewLine + ex.Message + Environment.NewLine + ex.StackTrace);
    } catch {
        MessageBox.Show("不可恢复的WPF窗体线程异常，应用程序将退出！");
    }
}
 
private void Application_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
{
    try {
        Exception ex = e.Exception;
        MessageBox.Show("WPF窗体线程异常: " + Environment.NewLine + ex.Message + Environment.NewLine + ex.StackTrace);
    } catch {
        MessageBox.Show("不可恢复的WPF窗体线程异常，应用程序将退出！");
    }
}
</code>
						</pre>
					</div>
				</div>
			</div>

			<!--多线程异常-->
			<div class="title">多线程异常</div>
			<div class="content closed">
				<p>多线程的异常处理，要采用特殊的做法。从.NET2.0开始，任何线程上未处理的异常，都会导致应用程序的退出（先会触发AppDomain的UnhandledException）。</p>
				<div class="container-fluid pl-0">
					<div class="row">
						<div class="col-6">
							<pre class="prettyprint linenums">
<code>
// catch的是主线程中的异常, 子线程中的异常没有catch!
try {
    Thread t = new Thread((ThreadStart)delegate {
        throw new Exception("多线程异常");
    });
    t.Start();
} catch (Exception error) {
    MessageBox.Show("主线程异常!");
}
</code>
							</pre>	
						</div>
						<div class="col-6">
							<pre class="prettyprint linenums">
<code>
// catch的是子线程中的异常, 主线程中的异常没有catch!
Thread t = new Thread((ThreadStart)delegate {
    try {
        throw new Exception("多线程异常");
    } catch (Exception error) {
        MessageBox.Show("工作线程异常!");
    }
});
t.Start();
</code>
							</pre>	
						</div>
					</div>
				</div>

				<p class="text-important">原则上来说，每个线程自己的异常应该在自己的内部处理完毕，不过仍旧有一个办法，可以将线程内部的异常传递到主线程。</p>
				<div class="container-fluid pl-0">
					<div class="row">
						<div class="col-6">
							<p>1) 在Windows窗体程序中，可以使用窗体的BeginInvoke方法来将异常传递给主窗体线程： </p>
							<pre class="prettyprint linenums">
<code>
// WinForm: 将子线程中的异常传递到主线程
Thread t = new Thread((ThreadStart)delegate {
    try {
        throw new Exception("非窗体线程异常");
    } catch (Exception ex) {
        this.BeginInvoke((Action)delegate {    // Action委托.NET 3.5才支持       
            throw ex;
        });
    }
});
t.Start();
</code>
							</pre>
						</div>
						<div class="col-6">
							<p>2) 在WPF窗体程序中，你可以采用如下的方法将 子线程的异常传递到主线程：</p>
							<pre class="prettyprint linenums">
<code>
// WPF: 将子线程中的异常传递到主线程
Thread t = new Thread((ThreadStart)delegate {
    try {
        throw new Exception("非窗体线程异常");
    } catch (Exception ex) {
        this.Dispatcher.Invoke((Action)delegate
        {
            throw ex;
        });
    }
});
t.Start();
</code>
							</pre>
						</div>
					</div>
				</div>
			</div>


		</div>
    </div>
</div>
{include file="template/footer" /}